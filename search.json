[{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"the-lmmsolver-package","dir":"Articles","previous_headings":"","what":"The LMMsolver package","title":"Solving Linear Mixed Models using LMMsolver","text":"aim LMMsolver package provide efficient flexible system estimate variance components using restricted maximum likelihood REML (Patterson Thompson 1971), models mixed model equations sparse. example application using splines model spatial (Rodríguez-Álvarez et al. 2018; Boer, Piepho, Williams 2020) temporal (Bustos-Korts et al. 2019) trends. Another example mixed model Quantitative Trait Locus (QTL) analysis multiparental populations, allowing heterogeneous residual variance design matrices Identity--Descent (IBD) probabilities (Li et al. 2021). Linear Mixed Model (LMM) form \\[   y = X \\beta + Z u + e, \\quad u \\sim N(0,G), \\quad e \\sim N(0,R)  \\] \\(y\\) vector observations, \\(\\beta\\) vector fixed effects, \\(u\\) vector random effects, \\(e\\) vector random residuals. \\(X\\) \\(Z\\) design matrices. LMMsolve package can fit models matrices \\(G^{-1}\\) \\(R^{-1}\\) linear combination precision matrices \\(Q_{G,}\\) \\(Q_{R,}\\): \\[   G^{-1} = \\sum_{} \\psi_i Q_{G,} \\;, \\quad   R^{-1} = \\sum_{} \\phi_i Q_{R,}  \\] precision parameters \\(\\psi_i\\) \\(\\phi_i\\) estimated using REML. standard mixed models \\(1/{\\psi_i}\\) variance components \\(1/{\\phi_i}\\) residual variances. use formulation terms precision parameters allow non-standard mixed models using tensor product splines introduced Rodríguez-Álvarez et al. (2015). matrices \\(G^{-1}\\) \\(R^{-1}\\) sparse, mixed model equations can solved using efficient sparse matrix algebra implemented spam package (Furrer Sain 2010). calculate derivatives log-likelihood efficient way, automatic differentiation Cholesky matrix (Smith 1995) implemented C++ using Rcpp package (Eddelbuettel Balamuta 2018).","code":""},{"path":[]},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"oats-field-trial","dir":"Articles","previous_headings":"Smooth trend in one dimension.","what":"Oats field trial","title":"Solving Linear Mixed Models using LMMsolver","text":"first example use oats field trial agridat package. 24 varieties 3 replicates, consisting 6 incomplete blocks 4 plots. plots laid single row. following subsections use two methods correct spatial trend, show options package.","code":"## Load data. data(john.alpha, package = \"agridat\") head(john.alpha) #>   plot rep block gen  yield row col #> 1    1  R1    B1 G11 4.1172   1   1 #> 2    2  R1    B1 G04 4.4461   2   1 #> 3    3  R1    B1 G05 5.8757   3   1 #> 4    4  R1    B1 G22 4.5784   4   1 #> 5    5  R1    B2 G21 4.6540   5   1 #> 6    6  R1    B2 G10 4.1736   6   1"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"modelling-spatial-trend-using-p-splines","dir":"Articles","previous_headings":"Smooth trend in one dimension. > Oats field trial","what":"Modelling spatial trend using P-splines","title":"Solving Linear Mixed Models using LMMsolver","text":"subsection illustrate package can used fit mixed model P-splines, details see Boer, Piepho, Williams (2020). following mixed model include rep gen fixed effect, use spl1D model one dimensional P-spline (Eilers Marx 1996) 100 segments, default choice cubical B-splines second order differences: high number segments can used splines one dimension, corresponding mixed model equations sparse, therefore can solved fast (Smith 1995; Furrer Sain 2010). can obtain table effective dimensions (see e.g. Rodríguez-Álvarez et al. (2018)) penalties (precision parameters \\(\\psi_i\\) \\(\\phi_i\\)) using summary function: effective dimension gives good balance model complexity fit data random terms model. table first four terms fixed effects penalized, therefore effective dimension equal number parameters model. splF fixed part spline, linear trend. term s(plot) random effect, effective dimension 4.2, indicating important correct spatial trend. estimated genetic effects given coef function: first genotype (G01) reference, genotypes modelled fixed effect model. smooth trend standard errors along field dense grid 1000 points can obtained follows: trend can plotted.","code":"## Fit mixed model with fixed and spline part. obj1 <- LMMsolve(fixed = yield ~ rep + gen,                  spline = ~spl1D(x = plot, nseg = 100),                  data = john.alpha) round(deviance(obj1), 2) #> [1] 49.87 summary(obj1) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00    0.00 #>          rep      2.00     2       2  1.00    0.00 #>          gen     23.00    23      23  1.00    0.00 #>    lin(plot)      1.00     1       1  1.00    0.00 #>      s(plot)      4.18   103      45  0.09 3430.91 #>     residual     40.82    72      45  0.91   13.28 #>  #>  Total Effective Dimension: 72 genEff <- coef(obj1)$gen head(genEff, 4) #>    gen_G01    gen_G02    gen_G03    gen_G04  #>  0.0000000 -0.5699723 -1.5231694 -0.4593976 ## Extract smooth trend from mixed model. plotDat1 <- obtainSmoothTrend(obj1, grid = 1000, includeIntercept = TRUE) head(plotDat1) #>       plot    ypred        se #> 1 1.000000 5.036407 0.2462877 #> 2 1.071071 5.035390 0.2448791 #> 3 1.142142 5.034371 0.2434969 #> 4 1.213213 5.033351 0.2421410 #> 5 1.284284 5.032329 0.2408117 #> 6 1.355355 5.031305 0.2395088 ## Plot smooth trend. ggplot(data = plotDat1, aes(x = plot, y = ypred)) +   geom_line(color = \"red\", size = 1) +   labs(title = \"Smooth spatial trend oats data\", x = \"plotnr\", y = \"yield\") +   theme(panel.grid = element_blank())"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"modelling-spatial-trend-using-random-and-ginverse-arguments-","dir":"Articles","previous_headings":"Smooth trend in one dimension. > Oats field trial","what":"Modelling spatial trend using random and ginverse arguments.","title":"Solving Linear Mixed Models using LMMsolver","text":"Another way correct spatial trend using Linear Variance (LV) model, closely connected P-splines model (Boer, Piepho, Williams 2020). First need define precision matrix LV model, see Appendix Boer, Piepho, Williams (2020) details: Given precision matrix LV model can define model LMMsolve using random ginverse arguments: deviance LV-model 54.49 variances reported Boer, Piepho, Williams (2020), Table 1.","code":"## Add plot as factor. john.alpha$plotF <- as.factor(john.alpha$plot) ## Define the precision matrix, see eqn (A2) in Boer et al (2020). N <- nrow(john.alpha) cN <- c(1 / sqrt(N - 1), rep(0, N - 2), 1 / sqrt(N - 1)) D <- diff(diag(N), diff = 1) Delta <- 0.5 * crossprod(D) LVinv <- 0.5 * (2 * Delta + cN %*% t(cN)) ## Add LVinv to list, with name corresponding to random term. lGinv <- list(plotF = LVinv) ## Fit mixed model with first degree B-splines and first order differences. obj2 <- LMMsolve(fixed = yield ~ rep + gen,                  random = ~plotF,                   ginverse = lGinv,                   data = john.alpha) summary(obj2, which = \"variances\") #> Table with variances:  #>  #>   VarComp Variance #>     plotF     0.01 #>  residual     0.06"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"model-biomass-as-function-of-time-","dir":"Articles","previous_headings":"Smooth trend in one dimension.","what":"Model biomass as function of time.","title":"Solving Linear Mixed Models using LMMsolver","text":"section show example mixed model P-splines fit biomass function time. example use wheat data simulated crop growth model APSIM. data set included package. details simulated data see Bustos-Korts et al. (2019). first column environment, Emerald 1993, second column simulated genotype (g001), third column days sowing (das), last column simulated biomass medium measurement error. model can fitted effective dimensions : fitted smooth trend can obtained explained , standard error bands blue:  growth rate (first derivative) function time can obtained using deriv = 1 function obtainSmoothTrend:","code":"data(APSIMdat) head(APSIMdat) #>            env geno das   biomass #> 1 Emerald_1993 g001  20  65.57075 #> 2 Emerald_1993 g001  21  60.70499 #> 3 Emerald_1993 g001  22  74.06247 #> 4 Emerald_1993 g001  23  63.73951 #> 5 Emerald_1993 g001  24 101.88005 #> 6 Emerald_1993 g001  25  96.84971 obj2 <- LMMsolve(biomass ~ 1,                  spline = ~spl1D(x = das, nseg = 200),                   data = APSIMdat) summary(obj2) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00    0.00 #>     lin(das)      1.00     1       1  1.00    0.00 #>       s(das)      6.56   203     119  0.06    0.01 #>     residual    112.44   121     119  0.94    0.00 #>  #>  Total Effective Dimension: 121 plotDat2 <- obtainSmoothTrend(obj2, grid = 1000, includeIntercept = TRUE)  ggplot(data = APSIMdat, aes(x = das, y = biomass)) +   geom_point(size = 1.2) +   geom_line(data = plotDat2, aes(y = ypred), color = \"red\", size = 1) +   geom_line(data = plotDat2, aes(y = ypred-2*se), col='blue', size=1) +   geom_line(data = plotDat2, aes(y = ypred+2*se), col='blue', size=1) +   labs(title = \"APSIM biomass as function of time\",         x = \"days after sowing\", y = \"biomass (kg)\") +   theme(panel.grid = element_blank()) plotDatDt <- obtainSmoothTrend(obj2, grid = 1000, deriv = 1)  ggplot(data = plotDatDt, aes(x = das, y = ypred)) +   geom_line(color = \"red\", size = 1) +   labs(title = \"APSIM growth rate as function of time\",         x = \"days after sowing\", y = \"growth rate (kg/day)\") +   theme(panel.grid = element_blank())"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"smooth-trends-in-two-dimensions","dir":"Articles","previous_headings":"","what":"Smooth trends in two dimensions","title":"Solving Linear Mixed Models using LMMsolver","text":"two-dimensional mixed P-splines use model defined Rodríguez-Álvarez et al. (2015). example use USprecip data set spam package (Furrer Sain 2010), analysed Rodríguez-Álvarez et al. (2015). two-dimensional P-spline can defined spl2D() function, longitude latitude covariates. number segments chosen equal number segments used Rodríguez-Álvarez et al. (2015). summary function gives table effective dimensions penalty parameters: plot smooth trend can obtained similar way one-dimensional examples:  Instead using grid argument, newdata can used make predictions locations specified data.frame:","code":"## Get precipitation data from spam data(USprecip, package = \"spam\")  ## Only use observed data USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ] obj3 <- LMMsolve(fixed = anomaly ~ 1,                  spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                  data = USprecip) summary(obj3) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    302.60  1936    1932  0.16    0.26 #>         s(lat)    409.09  1936    1932  0.21    0.08 #>       residual   5190.31  5906    5902  0.88   13.53 #>  #>  Total Effective Dimension: 5906 plotDat3 <- obtainSmoothTrend(obj3, grid = c(200, 300), includeIntercept = TRUE) usa = maps::map(\"usa\", regions = \"main\", plot = FALSE) v <- sp::point.in.polygon(plotDat3$lon, plotDat3$lat, usa$x, usa$y) plotDat3 <- plotDat3[v == 1, ]  ggplot(plotDat3, aes(x = lon, y = lat, fill = ypred)) +   geom_tile(show.legend = TRUE) +   scale_fill_gradientn(colors = topo.colors(100))+   labs(title = \"Precipitation (anomaly)\", x = \"Longitude\", y = \"Latitude\") +   coord_fixed() +   theme(panel.grid = element_blank()) ## Predictions for new data, using city coordinates from maps package. data(us.cities, package = \"maps\") ## Column names have to match column names used for fitting the model. colnames(us.cities)[colnames(us.cities) == \"long\"] <- \"lon\" ## Select columns name, lat and lon us.cities <- us.cities[, c(1,4,5)] head(us.cities) #>         name   lat     lon #> 1 Abilene TX 32.45  -99.74 #> 2   Akron OH 41.08  -81.52 #> 3 Alameda CA 37.77 -122.26 #> 4  Albany GA 31.58  -84.18 #> 5  Albany NY 42.67  -73.80 #> 6  Albany OR 44.62 -123.09  pred3 <- obtainSmoothTrend(obj3, newdata = us.cities, includeIntercept = TRUE) head(pred3) #>         name   lat     lon       ypred         se #> 1 Abilene TX 32.45  -99.74 -0.50934072 0.12154783 #> 2   Akron OH 41.08  -81.52  1.04632989 0.08791260 #> 3 Alameda CA 37.77 -122.26  1.15536263 0.06550916 #> 4  Albany GA 31.58  -84.18  1.00461912 0.12751840 #> 5  Albany NY 42.67  -73.80  0.09537096 0.05353882 #> 6  Albany OR 44.62 -123.09  0.79867976 0.09363539"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"qtl-mapping-with-ibd-probabilities-","dir":"Articles","previous_headings":"","what":"QTL mapping with IBD probabilities.","title":"Solving Linear Mixed Models using LMMsolver","text":"QTL-mapping multiparental populations Identity--Descent (IBD) probabilities used genetic predictors mixed model (Li et al. 2021). following simulated example illustration. consists three parents (, B, C), two crosses AxB, AxC. AxB population 100 Doubled Haploids (DH), AxC 80 DHs. probabilities, pA, pB, pC, position genome close simulated QTL. simulated data included package. residual (genetic) variances two populations can different. Therefore need allow heterogeneous residual variances, can defined using residual argument LMMsolve: QTL-probabilities defined columns pA, pB, pC, can included random part mixed model using group argument: approximate \\(-log10(p)\\) value given estimated QTL effects parents , B, C given :","code":"## Load data for multiparental population. data(multipop) head(multipop) #>   cross     ind         pA         pB pC    pheno #> 1   AxB AxB0001 0.17258816 0.82741184  0 9.890637 #> 2   AxB AxB0002 0.82170793 0.17829207  0 6.546568 #> 3   AxB AxB0003 0.95968439 0.04031561  0 7.899249 #> 4   AxB AxB0004 0.96564081 0.03435919  0 4.462866 #> 5   AxB AxB0005 0.04838734 0.95161266  0 5.207757 #> 6   AxB AxB0006 0.95968439 0.04031561  0 5.265580 ## Fit null model. obj4 <- LMMsolve(fixed = pheno ~ cross,                   residual = ~cross,                   data = multipop) dev4 <- deviance(obj4) ## Fit alternative model - include QTL with probabilities defined in columns 3:5  lGrp <- list(QTL = 3:5) obj5 <- LMMsolve(fixed = pheno ~ cross,                   group = lGrp,                  random = ~grp(QTL),                  residual = ~cross,                  data = multipop)  dev5 <- deviance(obj5) ## Deviance difference between null and alternative model. dev <- dev4 - dev5 ## Calculate approximate p-value.  minlog10p <- -log10(0.5 * pchisq(dev, 1, lower.tail = FALSE)) round(minlog10p, 2) #> [1] 8.76 coef(obj5)$QTL #>     QTL_pA     QTL_pB     QTL_pC  #> -1.2676362  0.6829275  0.5847088"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"references","dir":"Articles","previous_headings":"QTL mapping with IBD probabilities.","what":"References","title":"Solving Linear Mixed Models using LMMsolver","text":"Boer, Martin P., Hans Peter Piepho, Emlyn R. Williams. 2020. “Linear Variance, P-splines Neighbour Differences Spatial Adjustment Field Trials: Related?” J. Agric. Biol. Environ. Stat. 25 (4): 676–98. https://doi.org/10.1007/S13253-020-00412-4. Bustos-Korts, Daniela, Martin P. Boer, Marcos Malosetti, Scott Chapman, Karine Chenu, Bangyou Zheng, Fred . van Eeuwijk. 2019. “Combining Crop Growth Modeling Statistical Genetic Modeling Evaluate Phenotyping Strategies.” Front. Plant Sci. 10 (November). https://doi.org/10.3389/fpls.2019.01491. Eddelbuettel, Dirk, James Joseph Balamuta. 2018. “Extending extitR extitC++: Brief Introduction extitRcpp.” American Statistician 72 (1): 28–36. https://doi.org/10.1080/00031305.2017.1375990. Eilers, PHC, BD Marx. 1996. “Flexible smoothing B-splines penalties.” Stat. Sci. https://www.jstor.org/stable/2246049. Furrer, R, SR Sain. 2010. “spam: sparse matrix R package emphasis MCMC methods Gaussian Markov random fields.” J. Stat. Softw. https://core.ac.uk/download/pdf/6340272.pdf. Li, Wenhao, Martin P. Boer, Chaozhi Zheng, Ronny V. L. Joosen, Fred . van Eeuwijk. 2021. “IBD-based mixed model approach QTL mapping multiparental populations.” Theor. Appl. Genet. 2021 1 (August): 1–18. https://doi.org/10.1007/S00122-021-03919-7. Patterson, HD, R Thompson. 1971. “Recovery inter-block information block sizes unequal.” Biometrika. https://doi.org/10.1093/biomet/58.3.545. Rodríguez-Álvarez, María Xosé, Martin P. Boer, Fred . van Eeuwijk, Paul H. C. Eilers. 2018. “Correcting spatial heterogeneity plant breeding experiments P-splines.” Spat. Stat. 23 (March): 52–71. https://doi.org/10.1016/J.SPASTA.2017.10.003. Rodríguez-Álvarez, María Xosé, Dae Jin Lee, Thomas Kneib, María Durbán, Paul Eilers. 2015. “Fast smoothing parameter separation multidimensional generalized P-splines: SAP algorithm.” Stat. Comput. 25 (5): 941–57. https://doi.org/10.1007/S11222-014-9464-2. Smith, S. P. 1995. “Differentiation Cholesky Algorithm.” J. Comput. Graph. Stat. 4 (2): 134. https://doi.org/10.2307/1390762.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin Boer. Author. Bart-Jan van Rossum. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Boer M, van Rossum B (2022). LMMsolver: Linear Mixed Model Solver. R package version 1.0.2.","code":"@Manual{,   title = {LMMsolver: Linear Mixed Model Solver},   author = {Martin Boer and Bart-Jan {van Rossum}},   year = {2022},   note = {R package version 1.0.2}, }"},{"path":"/index.html","id":"lmmsolver","dir":"","previous_headings":"","what":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"aim LMMsolver package provide efficient flexible system estimate variance components using restricted maximum likelihood REML (Patterson Thompson 1971), models mixed model equations sparse. example application using splines model spatial (Rodríguez-Álvarez et al. 2018; Boer, Piepho, Williams 2020) temporal (Bustos-Korts et al. 2019) trends. Another example mixed model Quantitative Trait Locus (QTL) analysis multiparental populations, allowing heterogeneous residual variance design matrices Identity--Descent (IBD) probabilities (Li et al. 2021).","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"Install CRAN: Install latest development version GitHub (requires remotes package):","code":"install.packages(\"LMMsolver\") remotes::install_github(\"Biometris/LMMsolver\", ref = \"develop\", dependencies = TRUE)"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"example functionality package use model defined Rodríguez-Álvarez et al. (2015). uses USprecip data set spam package (Furrer Sain 2010). two-dimensional P-spline can defined spl2D() function, longitude latitude covariates. number segments chosen equal number segments used Rodríguez-Álvarez et al. (2015). summary function gives table effective dimensions penalty parameters: spatial trend precipitation can now plotted map USA.  examples can found vignette.","code":"library(LMMsolver) library(ggplot2)  ## Get precipitation data from spam data(USprecip, package = \"spam\")  ## Only use observed data. USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ] obj1 <- LMMsolve(fixed = anomaly ~ 1,                  spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                  data = USprecip) summary(obj1) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    302.60  1936    1932  0.16    0.26 #>         s(lat)    409.09  1936    1932  0.21    0.08 #>       residual   5190.31  5906    5902  0.88   13.53 #>  #>  Total Effective Dimension: 5906 plotDat <- obtainSmoothTrend(obj1, grid = c(200, 300), includeIntercept = TRUE) usa = maps::map(\"usa\", regions = \"main\", plot = FALSE) v <- sp::point.in.polygon(plotDat$lon, plotDat$lat, usa$x, usa$y) plotDat <- plotDat[v == 1, ]  ggplot(plotDat, aes(x = lon, y = lat, fill = ypred)) +   geom_tile(show.legend = TRUE) +   scale_fill_gradientn(colors = topo.colors(100))+   labs(title = \"Precipitation (anomaly) US April 1948\", x = \"Longitude\", y = \"Latitude\") +   coord_fixed() +   theme(panel.grid = element_blank()) vignette(\"Solving_Linear_Mixed_Models\")"},{"path":"/index.html","id":"references","dir":"","previous_headings":"","what":"References","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"Boer, Martin P., Hans Peter Piepho, Emlyn R. Williams. 2020. “Linear Variance, P-splines Neighbour Differences Spatial Adjustment Field Trials: Related?” J. Agric. Biol. Environ. Stat. 25 (4): 676–98. https://doi.org/10.1007/S13253-020-00412-4. Bustos-Korts, Daniela, Martin P. Boer, Marcos Malosetti, Scott Chapman, Karine Chenu, Bangyou Zheng, Fred . van Eeuwijk. 2019. “Combining Crop Growth Modeling Statistical Genetic Modeling Evaluate Phenotyping Strategies.” Front. Plant Sci. 10 (November). https://doi.org/10.3389/fpls.2019.01491. Furrer, R, SR Sain. 2010. “spam: sparse matrix R package emphasis MCMC methods Gaussian Markov random fields.” J. Stat. Softw. https://core.ac.uk/download/pdf/6340272.pdf. Li, Wenhao, Martin P. Boer, Chaozhi Zheng, Ronny V. L. Joosen, Fred . van Eeuwijk. 2021. “IBD-based mixed model approach QTL mapping multiparental populations.” Theor. Appl. Genet. 2021 1 (August): 1–18. https://doi.org/10.1007/S00122-021-03919-7. Patterson, HD, R Thompson. 1971. “Recovery inter-block information block sizes unequal.” Biometrika. https://doi.org/10.1093/biomet/58.3.545. Rodríguez-Álvarez, María Xosé, Martin P. Boer, Fred . van Eeuwijk, Paul H. C. Eilers. 2018. “Correcting spatial heterogeneity plant breeding experiments P-splines.” Spat. Stat. 23 (March): 52–71. https://doi.org/10.1016/J.SPASTA.2017.10.003. Rodríguez-Álvarez, María Xosé, Dae Jin Lee, Thomas Kneib, María Durbán, Paul Eilers. 2015. “Fast smoothing parameter separation multidimensional generalized P-splines: SAP algorithm.” Stat. Comput. 25 (5): 941–57. https://doi.org/10.1007/S11222-014-9464-2.","code":""},{"path":"/reference/ADchol.html","id":null,"dir":"Reference","previous_headings":"","what":"Automatic differentiation Cholesky, ZtZ and P spam matrices,\nwith C = lambda[1]*P1 + lambda[2]*P2 + ..... — ADchol","title":"Automatic differentiation Cholesky, ZtZ and P spam matrices,\nwith C = lambda[1]*P1 + lambda[2]*P2 + ..... — ADchol","text":"Automatic differentiation Cholesky, ZtZ P spam matrices, C = lambda[1]*P1 + lambda[2]*P2 + .....","code":""},{"path":"/reference/ADchol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Automatic differentiation Cholesky, ZtZ and P spam matrices,\nwith C = lambda[1]*P1 + lambda[2]*P2 + ..... — ADchol","text":"","code":"ADchol(P_list)"},{"path":"/reference/APSIMdat.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"Simulated Biomass function time using APSIM wheat.","code":""},{"path":"/reference/APSIMdat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"","code":"APSIMdat"},{"path":"/reference/APSIMdat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"data.frame 121 rows 4 columns. env Environment, Emerald 1993 geno Simulated genotype g001 das Days sowing biomass Simulated biomass using APSIM; medium measurement error added","code":""},{"path":"/reference/APSIMdat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"Bustos-Korts et al. (2019) Combining Crop Growth Modeling Statistical Genetic Modeling Evaluate Phenotyping Strategies doi: 10.3389/FPLS.2019.01491","code":""},{"path":"/reference/Bsplines.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct design matrix for B-Splines — Bsplines","title":"Construct design matrix for B-Splines — Bsplines","text":"Construct design matrix B-Splines.","code":""},{"path":"/reference/Bsplines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct design matrix for B-Splines — Bsplines","text":"","code":"Bsplines(knots, x, deriv = 0)"},{"path":"/reference/Bsplines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct design matrix for B-Splines — Bsplines","text":"knots numerical vector knot positions. x numeric vector values evaluate B-spline functions derivatives. deriv numerical value. derivative given order evaluated x positions.","code":""},{"path":"/reference/DerivCholesky.html","id":null,"dir":"Reference","previous_headings":"","what":"This function saves result of partial derivatives of Cholesky to a\na spam matrix, and is used to calculate standard errors and for predictions. — DerivCholesky","title":"This function saves result of partial derivatives of Cholesky to a\na spam matrix, and is used to calculate standard errors and for predictions. — DerivCholesky","text":"function saves result partial derivatives Cholesky spam matrix, used calculate standard errors predictions.","code":""},{"path":"/reference/DerivCholesky.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"This function saves result of partial derivatives of Cholesky to a\na spam matrix, and is used to calculate standard errors and for predictions. — DerivCholesky","text":"","code":"DerivCholesky(cholC)"},{"path":"/reference/LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve Linear Mixed Models — LMMsolve","title":"Solve Linear Mixed Models — LMMsolve","text":"Solve Linear Mixed Models using REML.","code":""},{"path":"/reference/LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve Linear Mixed Models — LMMsolve","text":"","code":"LMMsolve(   fixed,   random = NULL,   spline = NULL,   group = NULL,   ginverse = NULL,   weights = NULL,   data,   residual = NULL,   tolerance = 1e-06,   trace = FALSE,   maxit = 250,   theta = NULL )"},{"path":"/reference/LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve Linear Mixed Models — LMMsolve","text":"fixed formula fixed part model. form \"response ~ pred\" random formula random part model. form \"~ pred\". spline formula spline part model. form \"~ spl1D()\", ~ spl2D()\" \"~spl3D()\". group named list component numeric vector specifying contiguous fields data considered single term. ginverse named list component symmetric matrix, precision matrix corresponding random term model. row column order precision matrices match order levels corresponding factor data. weights character string identifying column data use relative weights fit. Default value NULL, weights equal one. data data.frame containing modeling data. residual formula residual part model. form \"~ pred\". tolerance numerical value. convergence tolerance modified Henderson algorithm estimate variance components. trace progress algorithm printed? Default trace = FALSE. maxit numerical value. maximum number iterations algorithm. Default maxit = 250. theta initial values penalty precision parameters. Default NULL, precision parameters set equal 1.","code":""},{"path":"/reference/LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve Linear Mixed Models — LMMsolve","text":"object class LMMsolve representing fitted model. See LMMsolveObject full description components object.","code":""},{"path":"/reference/LMMsolve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve Linear Mixed Models — LMMsolve","text":"Linear Mixed Model (LMM) form $$y = X \\beta + Z u + e, u ~ N(0,G), e ~ N(0,R)$$ \\(y\\) vector observations, \\(\\beta\\) vector fixed effects, \\(u\\) vector random effects, \\(e\\) vector random residuals. \\(X\\) \\(Z\\) design matrices. LMMsolve can fit models matrices \\(G^{-1}\\) \\(R^{-1}\\) linear combination precision matrices \\(Q_{G,}\\) \\(Q_{R,}\\): $$G^{-1} = \\sum_{} \\psi_i Q_{G,} \\;, R^{-1} = \\sum_{} \\phi_i Q_{R,}$$ precision parameters \\(\\psi_i\\) \\(\\phi_i\\) estimated using REML. standard mixed models \\(1/{\\psi_i}\\) variance components \\(1/{\\phi_i}\\) residual variances. use formulation terms precision parameters allow non-standard mixed models using tensor product splines.","code":""},{"path":[]},{"path":"/reference/LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve Linear Mixed Models — LMMsolve","text":"","code":"## Fit models on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Fit the same model with genotype as random effect. LMM1_rand <- LMMsolve(fixed = yield ~ rep,                      random = ~gen,                      data = john.alpha)  ## Fit the model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  ## Fit models on multipop data included in the package. data(multipop)  ## The residual variances for the two populations can be different. ## Allow for heterogeneous residual variances using the residual argument. LMM2 <- LMMsolve(fixed = pheno ~ cross,                 residual = ~cross,                 data = multipop)  ## QTL-probabilities are defined by the columns pA, pB, pC. ## They can be included in the random part of the model by specifying the ## group argument and using grp() in the random part.  # Define groups by specifying columns in data corresponding to groups in a list. # Name used in grp() should match names specified in list. lGrp <- list(QTL = 3:5) LMM2_group <- LMMsolve(fixed = pheno ~ cross,                       group = lGrp,                       random = ~grp(QTL),                       residual = ~cross,                       data = multipop)"},{"path":"/reference/LMMsolveObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted LMMsolve Object — LMMsolveObject","title":"Fitted LMMsolve Object — LMMsolveObject","text":"object class LMMsolve returned LMMsolve function, representing fitted linear mixed model. Objects class methods generic functions coef, fitted, residuals, loglik deviance.","code":""},{"path":"/reference/LMMsolveObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted LMMsolve Object — LMMsolveObject","text":"object class LMMsolve contains following components: logL restricted log-likelihood convergence sigma2e residual error tau2e estimated variance components EDdf effective dimensions varPar number variance parameters variance component VarDf table variance components theta precision parameters coefficients estimated effects mixed model equations yhat fitted values residuals residuals nIter number iterations mixed model converge C mixed model coefficient matrix last iteration cholC cholesky decomposition coefficient matrix C constantREML REML constant dim dimensions fixed random terms mixed model term.labels.f names fixed terms mixed model term.labels.r names random terms mixed model splRes object definition spline argument","code":""},{"path":"/reference/LMMsolver-package.html","id":null,"dir":"Reference","previous_headings":"","what":"LMMsolver: Linear Mixed Model Solver — LMMsolver-package","title":"LMMsolver: Linear Mixed Model Solver — LMMsolver-package","text":"efficient flexible system solve sparse mixed model equations, models often used statistical genetics. Important applications use splines model spatial temporal trends. Another application area mixed model QTL analysis multiparental populations, allowing heterogeneous residual variance random design matrices Identity--Descent (IBD) probabilities.","code":""},{"path":"/reference/LMMsolver-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"LMMsolver: Linear Mixed Model Solver — LMMsolver-package","text":"Maintainer: Bart-Jan van Rossum bart-jan.vanrossum@wur.nl (ORCID) Authors: Martin Boer martin.boer@wur.nl (ORCID)","code":""},{"path":"/reference/PsplinesKnots.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct equally placed knots — PsplinesKnots","title":"Construct equally placed knots — PsplinesKnots","text":"Construct equally placed knots.","code":""},{"path":"/reference/PsplinesKnots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct equally placed knots — PsplinesKnots","text":"","code":"PsplinesKnots(xmin, xmax, degree, nseg)"},{"path":"/reference/PsplinesKnots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct equally placed knots — PsplinesKnots","text":"xmin numerical value. xmax numerical value. degree numerical value. nseg numerical value.","code":""},{"path":"/reference/PsplinesKnots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct equally placed knots — PsplinesKnots","text":"numerical vector knot positions.","code":""},{"path":"/reference/RowKronecker.html","id":null,"dir":"Reference","previous_headings":"","what":"Row-wise kronecker product — RowKronecker","title":"Row-wise kronecker product — RowKronecker","text":"Row-wise kronecker product","code":""},{"path":"/reference/RowKronecker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row-wise kronecker product — RowKronecker","text":"","code":"RowKronecker(X1, X2)"},{"path":"/reference/RowKronecker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row-wise kronecker product — RowKronecker","text":"X1 matrix. X2 matrix.","code":""},{"path":"/reference/RowKronecker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row-wise kronecker product — RowKronecker","text":"row-wise kronecker product X1 X2.","code":""},{"path":"/reference/calcNomEffDim.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate the Nominal Effective dimension — calcNomEffDim","title":"Calculate the Nominal Effective dimension — calcNomEffDim","text":"Calculate Nominal Effective dimension","code":""},{"path":"/reference/calcNomEffDim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate the Nominal Effective dimension — calcNomEffDim","text":"","code":"calcNomEffDim(X, Z, dim.r)"},{"path":"/reference/checkFormVars.html","id":null,"dir":"Reference","previous_headings":"","what":"Check variables in formula — checkFormVars","title":"Check variables in formula — checkFormVars","text":"Check variables formula present data. variables converted factor data.frame well.","code":""},{"path":"/reference/checkFormVars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check variables in formula — checkFormVars","text":"","code":"checkFormVars(formula, data)"},{"path":"/reference/checkGroup.html","id":null,"dir":"Reference","previous_headings":"","what":"Check group part — checkGroup","title":"Check group part — checkGroup","text":"Check variables group also specified grp() random part model vice versa.","code":""},{"path":"/reference/checkGroup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check group part — checkGroup","text":"","code":"checkGroup(random, group)"},{"path":"/reference/coef.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"Obtain coefficients mixed model equations LMMsolve object.","code":""},{"path":"/reference/coef.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"","code":"# S3 method for LMMsolve coef(object, ...)"},{"path":"/reference/coef.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"object object class LMMsolve ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/coef.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"list vectors, containing estimated effects fixed effect predictions random effect defined linear mixed model.","code":""},{"path":"/reference/coef.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain coefficients. coefs1 <- coef(LMM1)"},{"path":"/reference/constructCCt.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct constraint matrix — constructCCt","title":"Construct constraint matrix — constructCCt","text":"Construct constraint matrix","code":""},{"path":"/reference/constructCCt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct constraint matrix — constructCCt","text":"","code":"constructCCt(knots, pord)"},{"path":"/reference/constructCCt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct constraint matrix — constructCCt","text":"knots knot positions B-spline basis. pord order penalty matrix (pord=1 2).","code":""},{"path":"/reference/constructCCt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct constraint matrix — constructCCt","text":"q x q matrix type spam","code":""},{"path":"/reference/constructGinvSplines.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct list of Ginv matrices of splines — constructGinvSplines","title":"Construct list of Ginv matrices of splines — constructGinvSplines","text":"Construct list Ginv matrices splines","code":""},{"path":"/reference/constructGinvSplines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct list of Ginv matrices of splines — constructGinvSplines","text":"","code":"constructGinvSplines(q, knots, pord)"},{"path":"/reference/constructGinvSplines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct list of Ginv matrices of splines — constructGinvSplines","text":"q vector, dimension B-spline basis used. knots list knot positions dimension pord order penalty matrix (1 2).","code":""},{"path":"/reference/constructGinvSplines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct list of Ginv matrices of splines — constructGinvSplines","text":"list symmetric matrices length vector q.","code":""},{"path":"/reference/constructPenalty.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct the penalty matrix — constructPenalty","title":"Construct the penalty matrix — constructPenalty","text":"Construct scaled version P-splines penalty matrix, see details.","code":""},{"path":"/reference/constructPenalty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct the penalty matrix — constructPenalty","text":"","code":"constructPenalty(q, pord, dx)"},{"path":"/reference/constructPenalty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct the penalty matrix — constructPenalty","text":"q integer dimensions. pord order penalty. dx distance knots.","code":""},{"path":"/reference/constructPenalty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct the penalty matrix — constructPenalty","text":"qxq penalty matrix class spam","code":""},{"path":"/reference/constructPenalty.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct the penalty matrix — constructPenalty","text":"P-spline penalty matrix form \\(D'D\\), \\(D\\) `pord` order difference matrix. make penalty matrix stable many knots, scaled version used, \\((1/dx)^(2pord-1) D'D\\).","code":""},{"path":"/reference/constructRinv.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for constructing Rinv — constructRinv","title":"Helper function for constructing Rinv — constructRinv","text":"Helper function constructing Rinv","code":""},{"path":"/reference/constructRinv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for constructing Rinv — constructRinv","text":"","code":"constructRinv(df, residual, weights)"},{"path":"/reference/constructX.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct fixed part of the spline model — constructX","title":"Construct fixed part of the spline model — constructX","text":"Construct fixed part spline model","code":""},{"path":"/reference/constructX.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct fixed part of the spline model — constructX","text":"","code":"constructX(B, x, scaleX, pord)"},{"path":"/reference/constructX.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct fixed part of the spline model — constructX","text":"B matrix B-spline basis. x vector values x. scaleX logical. scaleX FALSE, original x used. scaleX TRUE, scaling used, based B-splines basis. details see code. pord order penalty, values 1 2.","code":""},{"path":"/reference/constructX.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct fixed part of the spline model — constructX","text":"matrix X","code":""},{"path":"/reference/deviance.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Deviance of an LMMsolve object — deviance.LMMsolve","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"Obtain deviance model fitted using LMMsolve.","code":""},{"path":"/reference/deviance.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"","code":"# S3 method for LMMsolve deviance(object, includeConstant = TRUE, ...)"},{"path":"/reference/deviance.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"object object class LMMsolve includeConstant constant restricted log-likelihood included. Default TRUE, example lme4 SAS. asreml constant omitted. ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/deviance.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"deviance fitted model.","code":""},{"path":"/reference/deviance.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. logLik(LMM1) #> [1] -34.95557  ## Obtain deviance. without constant. logLik(LMM1, includeConstant = FALSE) #> [1] 7.315605"},{"path":"/reference/diagnosticsMME.html","id":null,"dir":"Reference","previous_headings":"","what":"Give diagnostics for mixed model coefficient matrix C and the cholesky\ndecomposition — diagnosticsMME","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky\ndecomposition — diagnosticsMME","text":"Give diagnostics mixed model coefficient matrix C cholesky decomposition","code":""},{"path":"/reference/diagnosticsMME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky\ndecomposition — diagnosticsMME","text":"","code":"diagnosticsMME(object)"},{"path":"/reference/diagnosticsMME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky\ndecomposition — diagnosticsMME","text":"object object class LMMsolve.","code":""},{"path":"/reference/diagnosticsMME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky\ndecomposition — diagnosticsMME","text":"summary mixed model coefficient matrix choleski decomposition.","code":""},{"path":"/reference/diagnosticsMME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky\ndecomposition — diagnosticsMME","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. diagnosticsMME(LMM1) #> Summary of matrix C  #> Matrix object of class 'spam' of dimension 26x26, #>     with 168 (row-wise) nonzero elements. #>     Density of the matrix is 24.9%. #> Class 'spam' (32-bit) #>  #>  Summary of cholesky decomposition of C  #> Matrix object of class 'spam' of dimension 26x26, #>     with 98 (row-wise) nonzero elements. #>     Density of the matrix is 14.5%. #> Class 'spam' (32-bit)"},{"path":"/reference/displayMME.html","id":null,"dir":"Reference","previous_headings":"","what":"Display the sparseness of the mixed model coefficient matrix — displayMME","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"Display sparseness mixed model coefficient matrix","code":""},{"path":"/reference/displayMME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"","code":"displayMME(object, cholesky = FALSE)"},{"path":"/reference/displayMME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"object object class LMMsolve. cholesky cholesky decomposition coefficient matrix plotted?","code":""},{"path":"/reference/displayMME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"plot sparseness mixed model coefficient matrix.","code":""},{"path":"/reference/displayMME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. displayMME(LMM1)"},{"path":"/reference/expandGinv.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine two lists of Ginv matrices — expandGinv","title":"Combine two lists of Ginv matrices — expandGinv","text":"output combined list, dimension (d1+d2) x (d1+d2), matrices lGinv1 extended [A1 0]                                     [0  0]              lGinv2 extended [0  0]                                     [0 A2]","code":""},{"path":"/reference/expandGinv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine two lists of Ginv matrices — expandGinv","text":"","code":"expandGinv(lGinv1, lGinv2)"},{"path":"/reference/expandGinv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine two lists of Ginv matrices — expandGinv","text":"lGinv1 list sparse matrices. lGinv2 list sparse matrices.","code":""},{"path":"/reference/expandGinv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine two lists of Ginv matrices — expandGinv","text":"list sparse matrices dimension (d1+d2) x (d1+d2)","code":""},{"path":"/reference/fitted.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted values of an LMMsolve object. — fitted.LMMsolve","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"Obtain fitted values mixed model fitted using LMMSolve.","code":""},{"path":"/reference/fitted.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"","code":"# S3 method for LMMsolve fitted(object, ...)"},{"path":"/reference/fitted.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"object object class LMMsolve ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/fitted.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"vector fitted values.","code":""},{"path":"/reference/fitted.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain fitted values. fitted1 <- fitted(LMM1)"},{"path":"/reference/logLik.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"Obtain Restricted Maximum Log-Likelihood model fitted using LMMsolve.","code":""},{"path":"/reference/logLik.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"","code":"# S3 method for LMMsolve logLik(object, includeConstant = TRUE, ...)"},{"path":"/reference/logLik.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"object object class LMMsolve includeConstant constant restricted log-likelihood included. Default TRUE, example lme4 SAS. asreml constant omitted. ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/logLik.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"restricted maximum log-likelihood fitted model.","code":""},{"path":"/reference/logLik.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain log-likelihood. logLik(LMM1) #> [1] -34.95557  ## Obtain log-likelihood without constant. logLik(LMM1, includeConstant = FALSE) #> [1] 7.315605"},{"path":"/reference/multipop.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated QTL mapping data set — multipop","title":"Simulated QTL mapping data set — multipop","text":"Simulated QTL mapping data set","code":""},{"path":"/reference/multipop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated QTL mapping data set — multipop","text":"","code":"multipop"},{"path":"/reference/multipop.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated QTL mapping data set — multipop","text":"data.frame 180 rows 6 columns. cross Cross ID, two populations, AxB AxC ind Genotype ID pA Probability individual alleles parent pB Probability individual alleles parent B pC Probability individual alleles parent C pheno Simulated phenotypic value","code":""},{"path":"/reference/nameCoefs.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for naming coefficients. — nameCoefs","title":"Helper function for naming coefficients. — nameCoefs","text":"Helper function naming coefficients.","code":""},{"path":"/reference/nameCoefs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for naming coefficients. — nameCoefs","text":"","code":"nameCoefs(coefs, desMat, termLabels, s, e, data, group = NULL, type = \"fixed\")"},{"path":"/reference/normVec.html","id":null,"dir":"Reference","previous_headings":"","what":"Norm of a vector — normVec","title":"Norm of a vector — normVec","text":"Norm vector","code":""},{"path":"/reference/normVec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Norm of a vector — normVec","text":"","code":"normVec(x)"},{"path":"/reference/normVec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Norm of a vector — normVec","text":"x numerical vector.","code":""},{"path":"/reference/normVec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Norm of a vector — normVec","text":"norm vector x","code":""},{"path":"/reference/obtainSmoothTrend.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain Smooth Trend. — obtainSmoothTrend","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"Obtain smooth trend models fitted spline component.","code":""},{"path":"/reference/obtainSmoothTrend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"","code":"obtainSmoothTrend(   object,   grid = NULL,   newdata = NULL,   deriv = 0,   includeIntercept = FALSE,   which = 1 )"},{"path":"/reference/obtainSmoothTrend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"object object class LMMsolve. grid numeric vector length dimension fitted spline component. represents number grid points surface computed. newdata data.frame containing new points smooth trend computed. Column names include names used fitting spline model. deriv Derivative B-splines, default 0. moment implemented spl1D. includeIntercept value intercept included computed smooth trend? Ignored deriv > 0. integer, multiple splxD terms model. Default value 1.","code":""},{"path":"/reference/obtainSmoothTrend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"data.frame predictions smooth trend specified grid. standard errors saved `deriv` default value 0.","code":""},{"path":"/reference/obtainSmoothTrend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit a model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  ## Obtain the smooth trend for the fitted model on a dense grid. smooth1 <- obtainSmoothTrend(LMM1_spline,                             grid = 100)  ## Obtain the smooth trend on a new data set - plots 10 to 40. newdat <- data.frame(plot = 10:40) smooth2 <- obtainSmoothTrend(LMM1_spline,                             newdata = newdat)  ## The first derivative of the smooth trend can be obtained by setting deriv = 1. smooth3 <- obtainSmoothTrend(LMM1_spline,                             grid = 100,                             deriv = 1)  ## For examples of higher order splines see the vignette."},{"path":"/reference/removeIntercept.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove the intercept from a design matrix — removeIntercept","title":"Remove the intercept from a design matrix — removeIntercept","text":"Remove intercept design matrix","code":""},{"path":"/reference/removeIntercept.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove the intercept from a design matrix — removeIntercept","text":"","code":"removeIntercept(X)"},{"path":"/reference/removeIntercept.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove the intercept from a design matrix — removeIntercept","text":"X design matrix.","code":""},{"path":"/reference/removeIntercept.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove the intercept from a design matrix — removeIntercept","text":"matrix X one column, otherwise return NULL","code":""},{"path":"/reference/residuals.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals of an LMMsolve object. — residuals.LMMsolve","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"Obtain residuals mixed model fitted using LMMSolve.","code":""},{"path":"/reference/residuals.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"","code":"# S3 method for LMMsolve residuals(object, ...)"},{"path":"/reference/residuals.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"object object class LMMsolve ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/residuals.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"vector residuals.","code":""},{"path":"/reference/residuals.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain fitted values. residuals1 <- residuals(LMM1)"},{"path":"/reference/spl1D.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit P-splines — spl1D","title":"Fit P-splines — spl1D","text":"Fit multi dimensional P-splines using sparse implementation.","code":""},{"path":"/reference/spl1D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit P-splines — spl1D","text":"","code":"spl1D(x, nseg, pord = 2, degree = 3, scaleX = TRUE, xlim = range(x))  spl2D(   x1,   x2,   nseg,   pord = 2,   degree = 3,   scaleX = TRUE,   x1lim = range(x1),   x2lim = range(x2) )  spl3D(   x1,   x2,   x3,   nseg,   pord = 2,   degree = 3,   scaleX = TRUE,   x1lim = range(x1),   x2lim = range(x2),   x3lim = range(x3) )"},{"path":"/reference/spl1D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit P-splines — spl1D","text":"x, x1, x2, x3 variables data containing values x covariates. nseg number segments pord order penalty, default pord = 2 degree degree B-spline basis, default degree = 3 scaleX fixed effects scaled. xlim, x1lim, x2lim, x3lim numerical vector length 2 containing domain corresponding x covariate knots placed. Default set NULL (covariate range).","code":""},{"path":"/reference/spl1D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit P-splines — spl1D","text":"list following elements: X - design matrix fixed effect. intercept included. Z - design matrix random effect. lGinv - list precision matrices knots - list vectors knot positions dim.f - dimensions fixed effect. dim.r - dimensions random effect. term.labels.f - labels fixed effect terms. term.labels.r - labels random effect terms. x - list vectors spline variables. pord - order penalty. degree - degree B-spline basis. scaleX - logical indicating fixed effects scaled. EDnom - nominal effective dimensions.","code":""},{"path":"/reference/spl1D.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Fit P-splines — spl1D","text":"spl2D: 2-dimensional splines spl3D: 3-dimensional splines","code":""},{"path":[]},{"path":"/reference/spl1D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit P-splines — spl1D","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit a model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  summary(LMM1_spline) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00    0.00 #>          rep      2.00     2       2  1.00    0.00 #>          gen     23.00    23      23  1.00    0.00 #>    lin(plot)      1.00     1       1  1.00    0.00 #>      s(plot)      3.99    23      21  0.19 3310.83 #>     residual     41.01    72      45  0.91   13.21 #>  #>  Total Effective Dimension: 72   ## Fit model on US precipitation data from spam package. data(USprecip, package = \"spam\")  ## Only use observed data USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ]  ## Fit a model with a 2-dimensional P-spline. LMM2_spline <- LMMsolve(fixed = anomaly ~ 1,                        spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                        data = USprecip)  summary(LMM2_spline) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    302.60  1936    1932  0.16    0.26 #>         s(lat)    409.09  1936    1932  0.21    0.08 #>       residual   5190.31  5906    5902  0.88   13.53 #>  #>  Total Effective Dimension: 5906"},{"path":"/reference/summary.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Linear Mixed Model fits — summary.LMMsolve","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"Summary method class \"LMMsolve\". Creates either table effective dimensions (= \"dimensions\") table variances (= \"variances\").","code":""},{"path":"/reference/summary.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"","code":"# S3 method for LMMsolve summary(object, which = c(\"dimensions\", \"variances\"), ...)  # S3 method for summary.LMMsolve print(x, ...)"},{"path":"/reference/summary.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"object object class LMMsolve character string indicating summary table created. ... methods generic require additional arguments. None used method. x object class summary.LMMsolve, result call summary.LMM","code":""},{"path":"/reference/summary.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"data.frame either effective dimensions variances depending .","code":""},{"path":"/reference/summary.LMMsolve.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"print.summary.LMMsolve: print summary","code":""},{"path":"/reference/summary.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain table of effective dimensions. summ1 <- summary(LMM1) print(summ1) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)         1     1       1     1    0.00 #>          rep         2     2       2     1    0.00 #>          gen        23    23      23     1    0.00 #>     residual        46    72      46     1    7.43 #>  #>  Total Effective Dimension: 72   ## Obtain table of variances. summ2 <- summary(LMM1,                 which = \"variances\") print(summ2) #> Table with variances:  #>  #>   VarComp Variance #>  residual     0.13 #>"},{"path":"/news/index.html","id":"lmmsolver-102","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.2","title":"LMMsolver 1.0.2","text":"CRAN release: 2022-04-21 First second order derivatives now calculated correctly. Several small bugs fixed. Updated tests pass checks macM1.","code":""},{"path":"/news/index.html","id":"lmmsolver-101","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.1","title":"LMMsolver 1.0.1","text":"CRAN release: 2022-03-28 weights argument LMMsolve function added Function obtainSmoothTrend returns addition predictions standard errors. Generalized Additive Model (GAM) added one-dimensional splines, .e. spl1D() components can added spline argument LMMsolve function Improved efficiency calculating sparse inverse using super-nodes. Replaced original P-splines penalty D'D scaled version far stable many knots. Several bugs fixed.","code":""},{"path":"/news/index.html","id":"lmmsolver-100","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.0","title":"LMMsolver 1.0.0","text":"CRAN release: 2021-11-02 Initial CRAN version","code":""}]
