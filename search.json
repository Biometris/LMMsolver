[{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"the-lmmsolver-package","dir":"Articles","previous_headings":"","what":"The LMMsolver package","title":"Solving Linear Mixed Models using LMMsolver","text":"aim LMMsolver package provide efficient flexible system estimate variance components using restricted maximum likelihood REML (Patterson Thompson 1971), models mixed model equations sparse (Boer 2023). example application using splines model spatial (Rodríguez-Álvarez et al. 2018; Boer, Piepho, Williams 2020) temporal (Bustos-Korts et al. 2019) trends. Another example mixed model Quantitative Trait Locus (QTL) analysis multiparental populations, allowing heterogeneous residual variance design matrices Identity--Descent (IBD) probabilities (Li et al. 2021). Linear Mixed Model (LMM) form \\[   y = X \\beta + Z u + e, \\quad u \\sim N(0,G), \\quad e \\sim N(0,R) \\] \\(y\\) vector observations, \\(\\beta\\) vector fixed effects, \\(u\\) vector random effects, \\(e\\) vector random residuals. \\(X\\) \\(Z\\) design matrices. LMMsolve package can fit models matrices \\(G^{-1}\\) \\(R^{-1}\\) linear combination precision matrices \\(Q_{G,}\\) \\(Q_{R,}\\): \\[   G^{-1} = \\sum_{} \\psi_i Q_{G,} \\;, \\quad   R^{-1} = \\sum_{} \\phi_i Q_{R,} \\] precision parameters \\(\\psi_i\\) \\(\\phi_i\\) estimated using REML. standard mixed models \\(1/{\\psi_i}\\) variance components \\(1/{\\phi_i}\\) residual variances. use formulation terms precision parameters allow non-standard mixed models using tensor product splines introduced Rodríguez-Álvarez et al. (2015). matrices \\(G^{-1}\\) \\(R^{-1}\\) sparse, mixed model equations can solved using efficient sparse matrix algebra implemented spam package (Furrer Sain 2010). calculate derivatives log-likelihood efficient way, automatic differentiation Cholesky matrix (Smith 1995; Boer 2023) implemented C++ using Rcpp package (Eddelbuettel Balamuta 2018).","code":""},{"path":[]},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"oats-field-trial","dir":"Articles","previous_headings":"Smooth trend in one dimension.","what":"Oats field trial","title":"Solving Linear Mixed Models using LMMsolver","text":"first example use oats field trial agridat package. 24 varieties 3 replicates, consisting 6 incomplete blocks 4 plots. plots laid single row. following subsections use two methods correct spatial trend, show options package.","code":"## Load data. data(john.alpha, package = \"agridat\") head(john.alpha) #>   plot rep block gen  yield row col #> 1    1  R1    B1 G11 4.1172   1   1 #> 2    2  R1    B1 G04 4.4461   2   1 #> 3    3  R1    B1 G05 5.8757   3   1 #> 4    4  R1    B1 G22 4.5784   4   1 #> 5    5  R1    B2 G21 4.6540   5   1 #> 6    6  R1    B2 G10 4.1736   6   1"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"modelling-spatial-trend-using-p-splines","dir":"Articles","previous_headings":"Smooth trend in one dimension. > Oats field trial","what":"Modelling spatial trend using P-splines","title":"Solving Linear Mixed Models using LMMsolver","text":"subsection illustrate package can used fit mixed model P-splines, details see Boer, Piepho, Williams (2020). following mixed model include rep gen fixed effect, use spl1D model one dimensional P-spline (Eilers Marx 1996) 100 segments, default choice cubical B-splines second order differences: high number segments can used splines one dimension, corresponding mixed model equations sparse, therefore can solved fast (Smith 1995; Furrer Sain 2010). can obtain table effective dimensions (see e.g. Rodríguez-Álvarez et al. (2018)) penalties (precision parameters \\(\\psi_i\\) \\(\\phi_i\\)) using summary function: effective dimension gives good balance model complexity fit data random terms model. table first four terms fixed effects penalized, therefore effective dimension equal number parameters model. splF fixed part spline, linear trend. term s(plot) random effect, effective dimension 4.2, indicating important correct spatial trend. estimated genetic effects given coef function: first genotype (G01) reference, genotypes modelled fixed effect model. smooth trend standard errors along field dense grid 1000 points can obtained follows: trend can plotted.","code":"## Fit mixed model with fixed and spline part. obj1 <- LMMsolve(fixed = yield ~ rep + gen,                  spline = ~spl1D(x = plot, nseg = 100),                  data = john.alpha) round(deviance(obj1), 2) #> [1] 49.87 summary(obj1) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00    0.00 #>          rep      2.00     2       2  1.00    0.00 #>          gen     23.00    23      23  1.00    0.00 #>    lin(plot)      1.00     1       1  1.00    0.00 #>      s(plot)      4.18   103      45  0.09 3431.87 #>     residual     40.82    72      45  0.91   13.28 #>  #>  Total Effective Dimension: 72 genEff <- coef(obj1)$gen head(genEff, 4) #>    gen_G01    gen_G02    gen_G03    gen_G04  #>  0.0000000 -0.5699756 -1.5231789 -0.4593992 ## Extract smooth trend from mixed model. plotDat1 <- obtainSmoothTrend(obj1, grid = 1000, includeIntercept = TRUE) head(plotDat1) #>       plot    ypred        se #> 1 1.000000 5.036391 0.2462874 #> 2 1.071071 5.035374 0.2448789 #> 3 1.142142 5.034355 0.2434968 #> 4 1.213213 5.033335 0.2421411 #> 5 1.284284 5.032314 0.2408118 #> 6 1.355355 5.031290 0.2395091 ## Plot smooth trend. ggplot(data = plotDat1, aes(x = plot, y = ypred)) +   geom_line(color = \"red\", linewidth = 1) +   labs(title = \"Smooth spatial trend oats data\", x = \"plotnr\", y = \"yield\") +   theme(panel.grid = element_blank())"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"modelling-spatial-trend-using-random-and-ginverse-arguments-","dir":"Articles","previous_headings":"Smooth trend in one dimension. > Oats field trial","what":"Modelling spatial trend using random and ginverse arguments.","title":"Solving Linear Mixed Models using LMMsolver","text":"Another way correct spatial trend using Linear Variance (LV) model, closely connected P-splines model (Boer, Piepho, Williams 2020). First need define precision matrix LV model, see Appendix Boer, Piepho, Williams (2020) details: Given precision matrix LV model can define model LMMsolve using random ginverse arguments: deviance LV-model 54.49 variances reported Boer, Piepho, Williams (2020), Table 1.","code":"## Add plot as factor. john.alpha$plotF <- as.factor(john.alpha$plot) ## Define the precision matrix, see eqn (A2) in Boer et al (2020). N <- nrow(john.alpha) cN <- c(1 / sqrt(N - 1), rep(0, N - 2), 1 / sqrt(N - 1)) D <- diff(diag(N), diff = 1) Delta <- 0.5 * crossprod(D) LVinv <- 0.5 * (2 * Delta + cN %*% t(cN)) ## Add LVinv to list, with name corresponding to random term. lGinv <- list(plotF = LVinv) ## Fit mixed model with first degree B-splines and first order differences. obj2 <- LMMsolve(fixed = yield ~ rep + gen,                  random = ~plotF,                   ginverse = lGinv,                   data = john.alpha) summary(obj2, which = \"variances\") #> Table with variances:  #>  #>   VarComp Variance #>     plotF     0.01 #>  residual     0.06"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"model-biomass-as-function-of-time-","dir":"Articles","previous_headings":"Smooth trend in one dimension.","what":"Model biomass as function of time.","title":"Solving Linear Mixed Models using LMMsolver","text":"section show example mixed model P-splines fit biomass function time. example use wheat data simulated crop growth model APSIM. data set included package. details simulated data see Bustos-Korts et al. (2019). first column environment, Emerald 1993, second column simulated genotype (g001), third column days sowing (das), last column simulated biomass medium measurement error. model can fitted effective dimensions : fitted smooth trend can obtained explained , standard error bands blue:  growth rate (first derivative) function time can obtained using deriv = 1 function obtainSmoothTrend:","code":"data(APSIMdat) head(APSIMdat) #>            env geno das   biomass #> 1 Emerald_1993 g001  20  65.57075 #> 2 Emerald_1993 g001  21  60.70499 #> 3 Emerald_1993 g001  22  74.06247 #> 4 Emerald_1993 g001  23  63.73951 #> 5 Emerald_1993 g001  24 101.88005 #> 6 Emerald_1993 g001  25  96.84971 obj2 <- LMMsolve(biomass ~ 1,                  spline = ~spl1D(x = das, nseg = 200),                   data = APSIMdat) summary(obj2) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00    0.00 #>     lin(das)      1.00     1       1  1.00    0.00 #>       s(das)      6.56   203     119  0.06    0.01 #>     residual    112.44   121     119  0.94    0.00 #>  #>  Total Effective Dimension: 121 plotDat2 <- obtainSmoothTrend(obj2, grid = 1000, includeIntercept = TRUE)  ggplot(data = APSIMdat, aes(x = das, y = biomass)) +   geom_point(size = 1.2) +   geom_line(data = plotDat2, aes(y = ypred), color = \"red\", linewidth = 1) +   geom_line(data = plotDat2, aes(y = ypred-2*se), col='blue', linewidth = 1) +   geom_line(data = plotDat2, aes(y = ypred+2*se), col='blue', linewidth = 1) +   labs(title = \"APSIM biomass as function of time\",         x = \"days after sowing\", y = \"biomass (kg)\") +   theme(panel.grid = element_blank()) plotDatDt <- obtainSmoothTrend(obj2, grid = 1000, deriv = 1)  ggplot(data = plotDatDt, aes(x = das, y = ypred)) +   geom_line(color = \"red\", linewidth = 1) +   labs(title = \"APSIM growth rate as function of time\",         x = \"days after sowing\", y = \"growth rate (kg/day)\") +   theme(panel.grid = element_blank())"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"smooth-trends-in-two-dimensions","dir":"Articles","previous_headings":"","what":"Smooth trends in two dimensions","title":"Solving Linear Mixed Models using LMMsolver","text":"two-dimensional mixed P-splines use model defined Rodríguez-Álvarez et al. (2015). example use USprecip data set spam package (Furrer Sain 2010), analysed Rodríguez-Álvarez et al. (2015). two-dimensional P-spline can defined spl2D() function, longitude latitude covariates. number segments chosen equal number segments used Rodríguez-Álvarez et al. (2015). summary function gives table effective dimensions penalty parameters: plot smooth trend can obtained similar way one-dimensional examples:  Instead using grid argument, newdata can used make predictions locations specified data.frame:","code":"## Get precipitation data from spam data(USprecip, package = \"spam\")  ## Only use observed data USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ] obj3 <- LMMsolve(fixed = anomaly ~ 1,                  spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                  data = USprecip) summary(obj3) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    302.60  1936    1932  0.16    0.26 #>         s(lat)    409.09  1936    1932  0.21    0.08 #>       residual   5190.31  5906    5902  0.88   13.53 #>  #>  Total Effective Dimension: 5906 plotDat3 <- obtainSmoothTrend(obj3, grid = c(200, 300), includeIntercept = TRUE) plotDat3 <- sf::st_as_sf(plotDat3, coords = c(\"lon\", \"lat\")) usa <- sf::st_as_sf(maps::map(\"usa\", regions = \"main\", plot = FALSE)) sf::st_crs(usa) <- sf::st_crs(plotDat3) intersection <- sf::st_intersects(plotDat3, usa) plotDat3 <- plotDat3[!is.na(as.numeric(intersection)), ]  ggplot(usa) +    geom_sf(color = NA) +   geom_tile(data = plotDat3,              mapping = aes(geometry = geometry, fill = ypred),              linewidth = 0,             stat = \"sf_coordinates\") +   scale_fill_gradientn(colors = topo.colors(100))+   labs(title = \"Precipitation (anomaly)\",         x = \"Longitude\", y = \"Latitude\") +   coord_sf() +   theme(panel.grid = element_blank()) ## Predictions for new data, using city coordinates from maps package. data(us.cities, package = \"maps\") ## Column names have to match column names used for fitting the model. colnames(us.cities)[colnames(us.cities) == \"long\"] <- \"lon\" ## Select columns name, lat and lon us.cities <- us.cities[, c(1,4,5)] head(us.cities) #>         name   lat     lon #> 1 Abilene TX 32.45  -99.74 #> 2   Akron OH 41.08  -81.52 #> 3 Alameda CA 37.77 -122.26 #> 4  Albany GA 31.58  -84.18 #> 5  Albany NY 42.67  -73.80 #> 6  Albany OR 44.62 -123.09  pred3 <- obtainSmoothTrend(obj3, newdata = us.cities, includeIntercept = TRUE) head(pred3) #>         name   lat     lon       ypred         se #> 1 Abilene TX 32.45  -99.74 -0.50934296 0.12154785 #> 2   Akron OH 41.08  -81.52  1.04632673 0.08791266 #> 3 Alameda CA 37.77 -122.26  1.15536050 0.06550927 #> 4  Albany GA 31.58  -84.18  1.00461677 0.12751835 #> 5  Albany NY 42.67  -73.80  0.09537157 0.05353887 #> 6  Albany OR 44.62 -123.09  0.79867839 0.09363536"},{"path":"/articles/Solving_Linear_Mixed_Models.html","id":"qtl-mapping-with-ibd-probabilities-","dir":"Articles","previous_headings":"","what":"QTL mapping with IBD probabilities.","title":"Solving Linear Mixed Models using LMMsolver","text":"QTL-mapping multiparental populations Identity--Descent (IBD) probabilities used genetic predictors mixed model (Li et al. 2021). following simulated example illustration. consists three parents (, B, C), two crosses AxB, AxC. AxB population 100 Doubled Haploids (DH), AxC 80 DHs. probabilities, pA, pB, pC, position genome close simulated QTL. simulated data included package. residual (genetic) variances two populations can different. Therefore need allow heterogeneous residual variances, can defined using residual argument LMMsolve: QTL-probabilities defined columns pA, pB, pC, can included random part mixed model using group argument: approximate \\(-log10(p)\\) value given estimated QTL effects parents , B, C given :","code":"## Load data for multiparental population. data(multipop) head(multipop) #>   cross     ind         pA         pB pC    pheno #> 1   AxB AxB0001 0.17258816 0.82741184  0 9.890637 #> 2   AxB AxB0002 0.82170793 0.17829207  0 6.546568 #> 3   AxB AxB0003 0.95968439 0.04031561  0 7.899249 #> 4   AxB AxB0004 0.96564081 0.03435919  0 4.462866 #> 5   AxB AxB0005 0.04838734 0.95161266  0 5.207757 #> 6   AxB AxB0006 0.95968439 0.04031561  0 5.265580 ## Fit null model. obj4 <- LMMsolve(fixed = pheno ~ cross,                   residual = ~cross,                   data = multipop) dev4 <- deviance(obj4) ## Fit alternative model - include QTL with probabilities defined in columns 3:5  lGrp <- list(QTL = 3:5) obj5 <- LMMsolve(fixed = pheno ~ cross,                   group = lGrp,                  random = ~grp(QTL),                  residual = ~cross,                  data = multipop)  dev5 <- deviance(obj5) ## Deviance difference between null and alternative model. dev <- dev4 - dev5 ## Calculate approximate p-value.  minlog10p <- -log10(0.5 * pchisq(dev, 1, lower.tail = FALSE)) round(minlog10p, 2) #> [1] 8.76 coef(obj5)$QTL #>     QTL_pA     QTL_pB     QTL_pC  #> -1.2676362  0.6829275  0.5847088"},{"path":[]},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin Boer. Author. Bart-Jan van Rossum. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin P. Boer (2023). Tensor product P-splines using sparse mixed model formulation Statistical Modelling 23 465 - 479 URL https://doi.org/10.1177/1471082X231178591","code":"@Article{,   title = {Tensor product {P}-splines using a sparse mixed model formulation},   author = {{Martin P. Boer}},   journal = {Statistical Modelling},   year = {2023},   volume = {23},   number = {5-6},   pages = {465 - 479},   doi = {10.1177/1471082X231178591}, }"},{"path":"/index.html","id":"lmmsolver","dir":"","previous_headings":"","what":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"aim LMMsolver package provide efficient flexible system estimate variance components using restricted maximum likelihood REML (Patterson Thompson 1971), models mixed model equations sparse (Boer 2023). example application using splines model spatial (Rodríguez-Álvarez et al. 2018; Boer, Piepho, Williams 2020) temporal (Bustos-Korts et al. 2019) trends. Another example mixed model Quantitative Trait Locus (QTL) analysis multiparental populations, allowing heterogeneous residual variance design matrices Identity--Descent (IBD) probabilities (Li et al. 2021).","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"Install CRAN: Install latest development version GitHub (requires remotes package):","code":"install.packages(\"LMMsolver\") remotes::install_github(\"Biometris/LMMsolver\", ref = \"develop\", dependencies = TRUE)"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"example functionality package use model defined Rodríguez-Álvarez et al. (2015). uses USprecip data set spam package (Furrer Sain 2010). two-dimensional P-spline can defined spl2D() function, longitude latitude covariates. number segments chosen equal number segments used Rodríguez-Álvarez et al. (2015). summary function gives table effective dimensions penalty parameters: spatial trend precipitation can now plotted map USA.  examples can found vignette.","code":"library(LMMsolver) library(ggplot2)  ## Get precipitation data from spam data(USprecip, package = \"spam\")  ## Only use observed data. USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ] obj1 <- LMMsolve(fixed = anomaly ~ 1,                  spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                  data = USprecip) summary(obj1) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    302.60  1936    1932  0.16    0.26 #>         s(lat)    409.09  1936    1932  0.21    0.08 #>       residual   5190.31  5906    5902  0.88   13.53 #>  #>  Total Effective Dimension: 5906 plotDat <- obtainSmoothTrend(obj1, grid = c(200, 300), includeIntercept = TRUE) plotDat <- sf::st_as_sf(plotDat, coords = c(\"lon\", \"lat\")) usa <- sf::st_as_sf(maps::map(\"usa\", regions = \"main\", plot = FALSE)) sf::st_crs(usa) <- sf::st_crs(plotDat) intersection <- sf::st_intersects(plotDat, usa) plotDat <- plotDat[!is.na(as.numeric(intersection)), ]  ggplot(usa) +    geom_sf(color = NA) +   geom_tile(data = plotDat,              mapping = aes(geometry = geometry, fill = ypred),              linewidth = 0,             stat = \"sf_coordinates\") +   scale_fill_gradientn(colors = topo.colors(100))+   labs(title = \"Precipitation (anomaly)\",         x = \"Longitude\", y = \"Latitude\") +   coord_sf() +   theme(panel.grid = element_blank()) vignette(\"Solving_Linear_Mixed_Models\")"},{"path":[]},{"path":"/reference/ADchol.html","id":null,"dir":"Reference","previous_headings":"","what":"construct object for Automated Differentiation Cholesky decomposition — ADchol","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"Construct object reverse Automated Differentiation Cholesky decomposition, input list semi-positive symmetric sparse matrices \\(P_i\\), dimension \\(q \\times q\\). function ADchol calculates matrix \\(C\\), sum precision matrices \\(P_i\\): \\(C = \\sum_{}  P_i\\). Next, calculates Cholesky Decomposition using multiple minimum degree (MMD) algorithm spam package.","code":""},{"path":"/reference/ADchol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"","code":"ADchol(lP)"},{"path":"/reference/ADchol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"lP list symmetric matrices class spam, dimension \\(q \\times q\\), sum matrices assumed positive definite.","code":""},{"path":"/reference/ADchol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"object class ADchol. object used calculate partial partial derivatives \\(log|C|\\) efficient way.","code":""},{"path":"/reference/ADchol.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"Furrer, R., & Sain, S. R. (2010). spam: sparse matrix R package emphasis MCMC methods Gaussian Markov random fields. Journal Statistical Software, 36, 1-25.","code":""},{"path":"/reference/APSIMdat.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"Simulated Biomass function time using APSIM wheat.","code":""},{"path":"/reference/APSIMdat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"","code":"APSIMdat"},{"path":"/reference/APSIMdat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"data.frame 121 rows 4 columns. env Environment, Emerald 1993 geno Simulated genotype g001 das Days sowing biomass Simulated biomass using APSIM; medium measurement error added","code":""},{"path":"/reference/APSIMdat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"Bustos-Korts et al. (2019) Combining Crop Growth Modeling Statistical Genetic Modeling Evaluate Phenotyping Strategies doi:10.3389/FPLS.2019.01491","code":""},{"path":"/reference/Bsplines.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct design matrix for B-Splines — Bsplines","title":"Construct design matrix for B-Splines — Bsplines","text":"Construct design matrix B-Splines.","code":""},{"path":"/reference/Bsplines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct design matrix for B-Splines — Bsplines","text":"","code":"Bsplines(knots, x, deriv = 0)"},{"path":"/reference/Bsplines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct design matrix for B-Splines — Bsplines","text":"knots numerical vector knot positions. x numeric vector values evaluate B-spline functions derivatives. deriv numerical value. derivative given order evaluated x positions.","code":""},{"path":"/reference/LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve Linear Mixed Models — LMMsolve","title":"Solve Linear Mixed Models — LMMsolve","text":"Solve Linear Mixed Models using REML.","code":""},{"path":"/reference/LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve Linear Mixed Models — LMMsolve","text":"","code":"LMMsolve(   fixed,   random = NULL,   spline = NULL,   group = NULL,   ginverse = NULL,   weights = NULL,   data,   residual = NULL,   family = gaussian(),   offset = 0,   tolerance = 1e-06,   trace = FALSE,   maxit = 250,   theta = NULL,   grpTheta = NULL )"},{"path":"/reference/LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve Linear Mixed Models — LMMsolve","text":"fixed formula fixed part model. form \"response ~ pred\" random formula random part model. form \"~ pred\". spline formula spline part model. form \"~ spl1D()\", ~ spl2D()\" \"~spl3D()\". group named list component numeric vector specifying contiguous fields data considered single term. ginverse named list component symmetric matrix, precision matrix corresponding random term model. row column order precision matrices match order levels corresponding factor data. weights character string identifying column data use relative weights fit. Default value NULL, weights equal one. data data.frame containing modeling data. residual formula residual part model. form \"~ pred\". family object class family specifying distribution link function. offset optional numerical vector containing priori known component included linear predictor fitting. tolerance numerical value. convergence tolerance modified Henderson algorithm estimate variance components. trace progress algorithm printed? Default trace = FALSE. maxit numerical value. maximum number iterations algorithm. Default maxit = 250. theta initial values penalty precision parameters. Default NULL, precision parameters set equal 1. grpTheta vector give components penalty. Default NULL, components separate penalty.","code":""},{"path":"/reference/LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve Linear Mixed Models — LMMsolve","text":"object class LMMsolve representing fitted model. See LMMsolveObject full description components object.","code":""},{"path":"/reference/LMMsolve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve Linear Mixed Models — LMMsolve","text":"Linear Mixed Model (LMM) form $$y = X \\beta + Z u + e, u ~ N(0,G), e ~ N(0,R)$$ \\(y\\) vector observations, \\(\\beta\\) vector fixed effects, \\(u\\) vector random effects, \\(e\\) vector random residuals. \\(X\\) \\(Z\\) design matrices. LMMsolve can fit models matrices \\(G^{-1}\\) \\(R^{-1}\\) linear combination precision matrices \\(Q_{G,}\\) \\(Q_{R,}\\): $$G^{-1} = \\sum_{} \\psi_i Q_{G,} \\;, R^{-1} = \\sum_{} \\phi_i Q_{R,}$$ precision parameters \\(\\psi_i\\) \\(\\phi_i\\) estimated using REML. standard mixed models \\(1/{\\psi_i}\\) variance components \\(1/{\\phi_i}\\) residual variances. use formulation terms precision parameters allow non-standard mixed models using tensor product splines.","code":""},{"path":[]},{"path":"/reference/LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve Linear Mixed Models — LMMsolve","text":"","code":"## Fit models on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Fit the same model with genotype as random effect. LMM1_rand <- LMMsolve(fixed = yield ~ rep,                      random = ~gen,                      data = john.alpha)  ## Fit the model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  ## Fit models on multipop data included in the package. data(multipop)  ## The residual variances for the two populations can be different. ## Allow for heterogeneous residual variances using the residual argument. LMM2 <- LMMsolve(fixed = pheno ~ cross,                 residual = ~cross,                 data = multipop)  ## QTL-probabilities are defined by the columns pA, pB, pC. ## They can be included in the random part of the model by specifying the ## group argument and using grp() in the random part.  # Define groups by specifying columns in data corresponding to groups in a list. # Name used in grp() should match names specified in list. lGrp <- list(QTL = 3:5) LMM2_group <- LMMsolve(fixed = pheno ~ cross,                       group = lGrp,                       random = ~grp(QTL),                       residual = ~cross,                       data = multipop)"},{"path":"/reference/LMMsolveObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted LMMsolve Object — LMMsolveObject","title":"Fitted LMMsolve Object — LMMsolveObject","text":"object class LMMsolve returned LMMsolve function, representing fitted linear mixed model. Objects class methods generic functions coef, fitted, residuals, loglik deviance.","code":""},{"path":"/reference/LMMsolveObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted LMMsolve Object — LMMsolveObject","text":"object class LMMsolve contains following components: logL restricted log-likelihood convergence sigma2e residual error tau2e estimated variance components EDdf effective dimensions varPar number variance parameters variance component VarDf table variance components theta precision parameters coefMME vector estimated effects mixed model equations ndxCoefficients indices coefficients names yhat fitted values residuals residuals nIter number iterations mixed model converge y Response variable X design matrix fixed part mixed model Z design matrix random part mixed model lGinv List precision matrices random terms lRinv List precision matrices residual C mixed model coefficient matrix last iteration cholC cholesky decomposition coefficient matrix C constantREML REML constant dim dimensions fixed random terms mixed model term.labels.f names fixed terms mixed model term.labels.r names random terms mixed model splRes object definition spline argument family object class family specifying distribution link function trace data.frame convergence sequence log likelihood effective dimensions .","code":""},{"path":"/reference/LMMsolver.html","id":null,"dir":"Reference","previous_headings":"","what":"Package LMMsolver — LMMsolver","title":"Package LMMsolver — LMMsolver","text":"Linear Mixed Model Solver using sparse matrix algebra.","code":""},{"path":"/reference/LMMsolver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Package LMMsolver — LMMsolver","text":"efficient flexible system solve sparse mixed model equations, models often used statistical genetics. Important applications use splines model spatial temporal trends. Another application area mixed model QTL analysis multiparental populations, allowing heterogeneous residual variance random design matrices Identity--Descent (IBD) probabilities.","code":""},{"path":"/reference/LMMsolver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Package LMMsolver — LMMsolver","text":"Martin P. Boer (2023). Tensor product P-splines using sparse mixed model formulation, Statistical Modelling, 23, p. 465 - 479. doi:10.1177/1471082X231178591","code":""},{"path":[]},{"path":"/reference/LMMsolver.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Package LMMsolver — LMMsolver","text":"Martin Boer martin.boer@wur.nl Bart-Jan van Rossum bart-jan.vanrossum@wur.nl (maintainer)","code":""},{"path":"/reference/PsplinesKnots.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct equally placed knots — PsplinesKnots","title":"Construct equally placed knots — PsplinesKnots","text":"Construct equally placed knots.","code":""},{"path":"/reference/PsplinesKnots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct equally placed knots — PsplinesKnots","text":"","code":"PsplinesKnots(xmin, xmax, degree, nseg)"},{"path":"/reference/PsplinesKnots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct equally placed knots — PsplinesKnots","text":"xmin numerical value. xmax numerical value. degree numerical value. nseg numerical value.","code":""},{"path":"/reference/PsplinesKnots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct equally placed knots — PsplinesKnots","text":"numerical vector knot positions.","code":""},{"path":"/reference/RowKronecker.html","id":null,"dir":"Reference","previous_headings":"","what":"Row-wise kronecker product — RowKronecker","title":"Row-wise kronecker product — RowKronecker","text":"Row-wise kronecker product","code":""},{"path":"/reference/RowKronecker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row-wise kronecker product — RowKronecker","text":"","code":"RowKronecker(X1, X2)"},{"path":"/reference/RowKronecker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row-wise kronecker product — RowKronecker","text":"X1 matrix. X2 matrix.","code":""},{"path":"/reference/RowKronecker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row-wise kronecker product — RowKronecker","text":"row-wise kronecker product X1 X2.","code":""},{"path":"/reference/calcStandardErrors.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard errors for predictions — calcStandardErrors","title":"Standard errors for predictions — calcStandardErrors","text":"Calculates standard errors predictions \\(D \\hat{u}\\), see Welham et al. 2004 Gilmour et al. 2004 details.","code":""},{"path":"/reference/calcStandardErrors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard errors for predictions — calcStandardErrors","text":"","code":"calcStandardErrors(C, D)"},{"path":"/reference/calcStandardErrors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standard errors for predictions — calcStandardErrors","text":"C symmetric matrix class spam D matrix class spam","code":""},{"path":"/reference/calcStandardErrors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standard errors for predictions — calcStandardErrors","text":"vector standard errors predictions \\(D \\hat{u}\\).","code":""},{"path":"/reference/calcStandardErrors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Standard errors for predictions — calcStandardErrors","text":"prediction error variance given \\(D C^{-1} D'\\), \\(C\\) mixed model coefficient matrix, \\(D\\) defines linear combinations fixed random effects. standard errors given square root diagonal. calculate standard errors efficient way use $$\\frac{\\partial log|C + \\xi_i d_i d_i'|}{\\partial \\xi_i} |_{\\xi_i=0}  = trace(C^{-1} d_i d_i') = trace(d_i' C^{-1} d_i) = d_i' C^{-1} d_i, $$ \\(d_i\\) row \\(\\) matrix \\(D\\). values \\(d_i' C^{-1} d_i\\) can calculated efficient, avoiding calculation inverse \\(C\\), using Automated Differentiation Choleksy algorithm, see section 2.3 Smith (1995) details.","code":""},{"path":"/reference/calcStandardErrors.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Standard errors for predictions — calcStandardErrors","text":"Welham, S., Cullis, B., Gogel, B., Gilmour, ., & Thompson, R. (2004). Prediction linear mixed models. Australian & New Zealand Journal Statistics, 46(3), 325-347. Smith, S. P. (1995). Differentiation Cholesky algorithm. Journal Computational Graphical Statistics, 4(2), 134-147. Gilmour, ., Cullis, B., Welham, S., Gogel, B., & Thompson, R. (2004). efficient computing strategy prediction mixed linear models. Computational statistics & data analysis, 44(4), 571-586.","code":""},{"path":"/reference/coef.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"Obtain coefficients mixed model equations LMMsolve object.","code":""},{"path":"/reference/coef.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"","code":"# S3 method for LMMsolve coef(object, se = FALSE, ...)"},{"path":"/reference/coef.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"object object class LMMsolve se calculate standard errors, default FALSE. ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/coef.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"list vectors, containing estimated effects fixed effect predictions random effect defined linear mixed model.","code":""},{"path":"/reference/coef.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain coefficients. coefs1 <- coef(LMM1)  ## Obtain coefficients with standard errors. coefs2 <- coef(LMM1, se = TRUE)"},{"path":"/reference/constructRinv.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for constructing Rinv — constructRinv","title":"Helper function for constructing Rinv — constructRinv","text":"Helper function constructing Rinv","code":""},{"path":"/reference/constructRinv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for constructing Rinv — constructRinv","text":"","code":"constructRinv(df, residual, weights)"},{"path":"/reference/deviance.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Deviance of an LMMsolve object — deviance.LMMsolve","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"Obtain deviance model fitted using LMMsolve.","code":""},{"path":"/reference/deviance.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"","code":"# S3 method for LMMsolve deviance(object, includeConstant = TRUE, ...)"},{"path":"/reference/deviance.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"object object class LMMsolve includeConstant constant restricted log-likelihood included. Default TRUE, example lme4 SAS. asreml constant omitted. ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/deviance.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"deviance fitted model.","code":""},{"path":"/reference/deviance.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. logLik(LMM1) #> [1] -34.95557  ## Obtain deviance. without constant. logLik(LMM1, includeConstant = FALSE) #> [1] 7.315605"},{"path":"/reference/diagnosticsMME.html","id":null,"dir":"Reference","previous_headings":"","what":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"Give diagnostics mixed model coefficient matrix C cholesky decomposition","code":""},{"path":"/reference/diagnosticsMME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"","code":"diagnosticsMME(object)"},{"path":"/reference/diagnosticsMME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"object object class LMMsolve.","code":""},{"path":"/reference/diagnosticsMME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"summary mixed model coefficient matrix choleski decomposition.","code":""},{"path":"/reference/diagnosticsMME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. diagnosticsMME(LMM1) #> Summary of matrix C  #> Matrix object of class 'spam' of dimension 26x26, #>     with 168 (row-wise) nonzero elements. #>     Density of the matrix is 24.9%. #> Class 'spam' (32-bit) #>  #>  Summary of cholesky decomposition of C  #> Matrix object of class 'spam' of dimension 26x26, #>     with 98 (row-wise) nonzero elements. #>     Density of the matrix is 14.5%. #> Class 'spam' (32-bit)"},{"path":"/reference/displayMME.html","id":null,"dir":"Reference","previous_headings":"","what":"Display the sparseness of the mixed model coefficient matrix — displayMME","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"Display sparseness mixed model coefficient matrix","code":""},{"path":"/reference/displayMME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"","code":"displayMME(object, cholesky = FALSE)"},{"path":"/reference/displayMME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"object object class LMMsolve. cholesky cholesky decomposition coefficient matrix plotted?","code":""},{"path":"/reference/displayMME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"plot sparseness mixed model coefficient matrix.","code":""},{"path":"/reference/displayMME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. displayMME(LMM1)"},{"path":"/reference/fitted.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted values of an LMMsolve object. — fitted.LMMsolve","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"Obtain fitted values mixed model fitted using LMMSolve.","code":""},{"path":"/reference/fitted.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"","code":"# S3 method for LMMsolve fitted(object, ...)"},{"path":"/reference/fitted.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"object object class LMMsolve ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/fitted.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"vector fitted values.","code":""},{"path":"/reference/fitted.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain fitted values. fitted1 <- fitted(LMM1)"},{"path":"/reference/logLik.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"Obtain Restricted Maximum Log-Likelihood model fitted using LMMsolve.","code":""},{"path":"/reference/logLik.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"","code":"# S3 method for LMMsolve logLik(object, includeConstant = TRUE, ...)"},{"path":"/reference/logLik.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"object object class LMMsolve includeConstant constant restricted log-likelihood included. Default TRUE, example lme4 SAS. asreml constant omitted. ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/logLik.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"restricted maximum log-likelihood fitted model.","code":""},{"path":"/reference/logLik.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain log-likelihood. logLik(LMM1) #> [1] -34.95557  ## Obtain log-likelihood without constant. logLik(LMM1, includeConstant = FALSE) #> [1] 7.315605"},{"path":"/reference/multipop.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated QTL mapping data set — multipop","title":"Simulated QTL mapping data set — multipop","text":"Simulated QTL mapping data set","code":""},{"path":"/reference/multipop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated QTL mapping data set — multipop","text":"","code":"multipop"},{"path":"/reference/multipop.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated QTL mapping data set — multipop","text":"data.frame 180 rows 6 columns. cross Cross ID, two populations, AxB AxC ind Genotype ID pA Probability individual alleles parent pB Probability individual alleles parent B pC Probability individual alleles parent C pheno Simulated phenotypic value","code":""},{"path":"/reference/obtainSmoothTrend.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain Smooth Trend. — obtainSmoothTrend","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"Obtain smooth trend models fitted spline component.","code":""},{"path":"/reference/obtainSmoothTrend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"","code":"obtainSmoothTrend(   object,   grid = NULL,   newdata = NULL,   deriv = 0,   includeIntercept = FALSE,   which = 1 )"},{"path":"/reference/obtainSmoothTrend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"object object class LMMsolve. grid numeric vector length dimension fitted spline component. represents number grid points surface computed. newdata data.frame containing new points smooth trend computed. Column names include names used fitting spline model. deriv Derivative B-splines, default 0. moment implemented spl1D. includeIntercept value intercept included computed smooth trend? Ignored deriv > 0. integer, multiple splxD terms model. Default value 1.","code":""},{"path":"/reference/obtainSmoothTrend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"data.frame predictions smooth trend specified grid. standard errors saved `deriv` default value 0.","code":""},{"path":"/reference/obtainSmoothTrend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit a model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  ## Obtain the smooth trend for the fitted model on a dense grid. smooth1 <- obtainSmoothTrend(LMM1_spline,                             grid = 100)  ## Obtain the smooth trend on a new data set - plots 10 to 40. newdat <- data.frame(plot = 10:40) smooth2 <- obtainSmoothTrend(LMM1_spline,                             newdata = newdat)  ## The first derivative of the smooth trend can be obtained by setting deriv = 1. smooth3 <- obtainSmoothTrend(LMM1_spline,                             grid = 100,                             deriv = 1)  ## For examples of higher order splines see the vignette."},{"path":"/reference/predictTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test function for predict, for the moment internal — predictTest","title":"Test function for predict, for the moment internal — predictTest","text":"Test function predict, moment internal","code":""},{"path":"/reference/predictTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test function for predict, for the moment internal — predictTest","text":"","code":"predictTest(object, classify)"},{"path":"/reference/residuals.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals of an LMMsolve object. — residuals.LMMsolve","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"Obtain residuals mixed model fitted using LMMSolve.","code":""},{"path":"/reference/residuals.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"","code":"# S3 method for LMMsolve residuals(object, ...)"},{"path":"/reference/residuals.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"object object class LMMsolve ... methods generic require additional arguments. None used method.","code":""},{"path":"/reference/residuals.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"vector residuals.","code":""},{"path":"/reference/residuals.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain fitted values. residuals1 <- residuals(LMM1)"},{"path":"/reference/spl1D.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit P-splines — spl1D","title":"Fit P-splines — spl1D","text":"Fit multi dimensional P-splines using sparse implementation.","code":""},{"path":"/reference/spl1D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit P-splines — spl1D","text":"","code":"spl1D(   x,   nseg,   pord = 2,   degree = 3,   scaleX = TRUE,   xlim = range(x),   cond = NULL,   level = NULL )  spl2D(   x1,   x2,   nseg,   pord = 2,   degree = 3,   scaleX = TRUE,   x1lim = range(x1),   x2lim = range(x2),   cond = NULL,   level = NULL )  spl3D(   x1,   x2,   x3,   nseg,   pord = 2,   degree = 3,   scaleX = TRUE,   x1lim = range(x1),   x2lim = range(x2),   x3lim = range(x3) )"},{"path":"/reference/spl1D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit P-splines — spl1D","text":"x, x1, x2, x3 variables data containing values x covariates. nseg number segments pord order penalty, default pord = 2 degree degree B-spline basis, default degree = 3 scaleX fixed effects scaled. xlim, x1lim, x2lim, x3lim numerical vector length 2 containing domain corresponding x covariate knots placed. Default set NULL, covariate range used. cond Conditional factor: splines defined conditional level. Default NULL. level level conditional factor. Default NULL.","code":""},{"path":"/reference/spl1D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit P-splines — spl1D","text":"list following elements: X - design matrix fixed effect. intercept included. Z - design matrix random effect. lGinv - list precision matrices knots - list vectors knot positions dim.f - dimensions fixed effect. dim.r - dimensions random effect. term.labels.f - labels fixed effect terms. term.labels.r - labels random effect terms. x - list vectors spline variables. pord - order penalty. degree - degree B-spline basis. scaleX - logical indicating fixed effects scaled. EDnom - nominal effective dimensions.","code":""},{"path":"/reference/spl1D.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Fit P-splines — spl1D","text":"spl2D(): 2-dimensional splines spl3D(): 3-dimensional splines","code":""},{"path":[]},{"path":"/reference/spl1D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit P-splines — spl1D","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit a model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  summary(LMM1_spline) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00    0.00 #>          rep      2.00     2       2  1.00    0.00 #>          gen     23.00    23      23  1.00    0.00 #>    lin(plot)      1.00     1       1  1.00    0.00 #>      s(plot)      3.99    23      21  0.19 3310.21 #>     residual     41.01    72      45  0.91   13.21 #>  #>  Total Effective Dimension: 72   ## Fit model on US precipitation data from spam package. data(USprecip, package = \"spam\")  ## Only use observed data USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ]  ## Fit a model with a 2-dimensional P-spline. LMM2_spline <- LMMsolve(fixed = anomaly ~ 1,                        spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                        data = USprecip)  summary(LMM2_spline) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    302.60  1936    1932  0.16    0.26 #>         s(lat)    409.09  1936    1932  0.21    0.08 #>       residual   5190.31  5906    5902  0.88   13.53 #>  #>  Total Effective Dimension: 5906"},{"path":"/reference/summary.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Linear Mixed Model fits — summary.LMMsolve","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"Summary method class \"LMMsolve\". Creates either table effective dimensions (= \"dimensions\") table variances (= \"variances\").","code":""},{"path":"/reference/summary.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"","code":"# S3 method for LMMsolve summary(object, which = c(\"dimensions\", \"variances\"), ...)  # S3 method for summary.LMMsolve print(x, ...)"},{"path":"/reference/summary.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"object object class LMMsolve character string indicating summary table created. ... methods generic require additional arguments. None used method. x object class summary.LMMsolve, result call summary.LMM","code":""},{"path":"/reference/summary.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"data.frame either effective dimensions variances depending .","code":""},{"path":"/reference/summary.LMMsolve.html","id":"methods-by-generic-","dir":"Reference","previous_headings":"","what":"Methods (by generic)","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"print(summary.LMMsolve): print summary","code":""},{"path":"/reference/summary.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain table of effective dimensions. summ1 <- summary(LMM1) print(summ1) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)         1     1       1     1    0.00 #>          rep         2     2       2     1    0.00 #>          gen        23    23      23     1    0.00 #>     residual        46    72      46     1    7.43 #>  #>  Total Effective Dimension: 72   ## Obtain table of variances. summ2 <- summary(LMM1,                 which = \"variances\") print(summ2) #> Table with variances:  #>  #>   VarComp Variance #>  residual     0.13 #>"},{"path":"/news/index.html","id":"lmmsolver-107","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.7","title":"LMMsolver 1.0.7","text":"Improved efficiency models residual argument LMMsolve() used. data.frame trace convergence sequence log-likelihood effective dimensions, added extra output returned LMMsolve(). Bug v1.0.6 GLMM models fixed. Coefficients three way interactions one factor two non-factors now labelled correctly. Standard errors function obtainSmoothTrend() GLMM models now calculated.","code":""},{"path":"/news/index.html","id":"lmmsolver-106","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.6","title":"LMMsolver 1.0.6","text":"CRAN release: 2023-11-27 new argument grpTheta LMMsolve() give components model penalty. dependency package sp replaced sf. small bug models 10.000 observations numeric variable random part model fixed. Weights now checked missing values removing observations missing values response. prevents spurious errors response weight missing.","code":""},{"path":"/news/index.html","id":"lmmsolver-105","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.5","title":"LMMsolver 1.0.5","text":"CRAN release: 2023-04-14 Small bugs assignment names fixed model coefficients columns dropped model fixed. Calculation standard errors coefficients, coef(obj, se = TRUE). Implementation Generalized Linear Mixed Models (GLMM) additional argument family LMMsolve function. Variance components splines can conditional factor. variance components, implemented cf(var, cond, level) function. 1D 2D splines, additional arguments cond level added. Several small bugs fixed.","code":""},{"path":"/news/index.html","id":"lmmsolver-104","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.4","title":"LMMsolver 1.0.4","text":"CRAN release: 2022-12-15 Improved computation time calculation standard errors. Implementation C++ using ‘sparse inverse’. Row-wise Kronecker product spam matrices implemented C++. Important tensor product P-splines improved computation time memory allocation.","code":""},{"path":"/news/index.html","id":"lmmsolver-103","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.3","title":"LMMsolver 1.0.3","text":"CRAN release: 2022-08-19 Improved computation time memory allocation, especially important big data many observations (number rows data frame). Replaced default model.matrix function Matrix::sparse.model.matrix generate sparse design matrices. function obtainSmoothTrend standard errors calculated includeIntercept = TRUE. Several small bugs fixed.","code":""},{"path":"/news/index.html","id":"lmmsolver-102","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.2","title":"LMMsolver 1.0.2","text":"CRAN release: 2022-04-21 First second order derivatives now calculated correctly. Several small bugs fixed. Updated tests pass checks macM1.","code":""},{"path":"/news/index.html","id":"lmmsolver-101","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.1","title":"LMMsolver 1.0.1","text":"CRAN release: 2022-03-28 weights argument LMMsolve function added Function obtainSmoothTrend returns addition predictions standard errors. Generalized Additive Model (GAM) added one-dimensional splines, .e. spl1D() components can added spline argument LMMsolve function Improved efficiency calculating sparse inverse using super-nodes. Replaced original P-splines penalty D'D scaled version far stable many knots. Several bugs fixed.","code":""},{"path":"/news/index.html","id":"lmmsolver-100","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.0","title":"LMMsolver 1.0.0","text":"CRAN release: 2021-11-02 Initial CRAN version","code":""}]
