[{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"the-lmmsolver-package","dir":"Articles","previous_headings":"","what":"The LMMsolver package","title":"Mixed Models and Smoothing","text":"aim LMMsolver package provide efficient flexible system estimate variance components using restricted maximum likelihood REML (Patterson Thompson 1971), models mixed model equations sparse. important feature package smoothing P-splines (Eilers Marx 1996). sparse mixed model P-splines formulation (Boer 2023) used, makes computations fast. computational advantage sparse mixed model formulation especially clear smoothing higher dimensions (Boer 2023; Carollo et al. 2024). Linear Mixed Model (LMM) form y=Xβ+Zu+e,u∼N(0,G),e∼N(0,R),   y = X \\beta + Z u + e, \\quad u \\sim N(0,G), \\quad e \\sim N(0,R) \\;,  yy vector observations, β\\beta vector fixed effects, uu vector random effects, ee vector random residuals. XX ZZ design matrices. matrices XX, ZZ, G−1G^{-1} R−1R^{-1} sparse, mixed model equations can solved using efficient sparse matrix algebra implemented spam package (Furrer Sain 2010). calculate derivatives log-likelihood efficient way, automatic differentiation Cholesky matrix (Smith 1995; Boer 2023) implemented C++ using Rcpp package (Eddelbuettel Balamuta 2018).","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Mixed Models and Smoothing","text":"purpose section give users easy introduction, starting simple linear regression. Based simulations explain main functions, input output. First load LMMsolver ggplot2 packages:","code":"library(LMMsolver) library(ggplot2)"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"linear-regression","dir":"Articles","previous_headings":"Introduction","what":"Linear Regression","title":"Mixed Models and Smoothing","text":"start simple example true function linear variable xx: Using function simulate data add normal distributed noise: can fit data using LMMsolve function: can make predictions using predict() function: Note linear model used standard lm() function, give result. following plot gives simulated data predictions, pointwise standard-error bands. true value plotted dashed red line.","code":"f1 <- function(x) { 0.6 + 0.7*x} set.seed(2016) n <- 25 x <- seq(0, 1, length = n) sigma2e <- 0.04 y <- f1(x) + rnorm(n, sd = sqrt(sigma2e)) dat1 <- data.frame(x = x, y = y) obj1 <- LMMsolve(fixed = y ~ x, data = dat1) newdat <- data.frame(x = seq(0, 1, length = 300)) pred1 <- predict(obj1, newdata = newdat, se.fit = TRUE) # adding the true values for comparison pred1$y_true <- f1(pred1$x) ggplot(data = dat1, aes(x = x, y = y)) +   geom_point(col = \"black\", size = 1.5) +   geom_line(data = pred1, aes(y=y_true), color = \"red\",              linewidth = 1, linetype = \"dashed\") +   geom_line(data = pred1, aes(y = ypred), color = \"blue\", linewidth = 1) +   geom_ribbon(data = pred1, aes(x=x,ymin = ypred-2*se, ymax = ypred+2*se),               alpha = 0.2, inherit.aes = FALSE) +    theme_bw()"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"fitting-a-non-linear-function","dir":"Articles","previous_headings":"Introduction","what":"Fitting a non-linear function","title":"Mixed Models and Smoothing","text":"section use following non-linear function simulations: simulated data generated following code can use spline argument fit non-linear trend: spl1D(x, nseg = 50) defines mixed model P-splines 50 segments. model fit can summarized terms effective dimensions: intercept slope lin(x) define linear (fixed) part model, non-linear (random) part defined s(x), effective dimension 11.28. Making predictions interval [0,1][0,1] plotting can done way linear regression example:","code":"f2 <- function(x) { 0.3 + 0.4*x + 0.2*sin(20*x) } set.seed(12) n <- 150 x <- seq(0, 1, length = n) sigma2e <- 0.04 y <- f2(x) + rnorm(n, sd = sqrt(sigma2e)) dat2 <- data.frame(x, y) obj2 <- LMMsolve(fixed = y ~ 1,                   spline = ~spl1D(x, nseg = 50),                   data = dat2) summary(obj2) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00     0.0 #>       lin(x)      1.00     1       1  1.00     0.0 #>         s(x)     11.28    53      51  0.22     0.0 #>     residual    136.72   150     148  0.92    30.3 #>  #>  Total Effective Dimension: 150 newdat <- data.frame(x = seq(0, 1, length = 300)) pred2 <- predict(obj2, newdata = newdat, se.fit = TRUE) pred2$y_true <- f2(pred2$x)  ggplot(data = dat2, aes(x = x, y = y)) +   geom_point(col = \"black\", size = 1.5) +   geom_line(data = pred2, aes(y = y_true), color = \"red\",              linewidth = 1, linetype =\"dashed\") +   geom_line(data = pred2, aes(y = ypred), color = \"blue\", linewidth = 1) +   geom_ribbon(data= pred2, aes(x=x, ymin = ypred-2*se, ymax = ypred+2*se),               alpha=0.2, inherit.aes = FALSE) +   theme_bw()"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"smoothing-combining-two-experiments","dir":"Articles","previous_headings":"Introduction","what":"Smoothing combining two experiments","title":"Mixed Models and Smoothing","text":"section give bit complicated example, show options LMMsolver. Suppose two experiments, B, true unobserved non-linear function f2(x) defined . simulated data given following code: analyzing data detail boxplot gives insight:  Comparing two experiments can see : clear difference mean/median two experiments. can corrected adding argument random = ~Experiment. variance experiment smaller B. implies important allow heterogeneous variances can modelled defining residual = ~Experiment. model LMMsolve() given : table effective dimensions given : making predictions:  estimated random effects Experiment can obtained using coef() function: sum effects equal zero, expected standard random term.","code":"set.seed(1234) nA <-  50 nB <- 100 mu_A <-  0.10 mu_B <- -0.10 sigma2e_A <- 0.04 sigma2e_B <- 0.10  x1 <- runif(n = nA) x2 <- runif(n = nB) y1 <- f2(x1) + rnorm(nA, sd = sqrt(sigma2e_A)) + mu_A y2 <- f2(x2) + rnorm(nB, sd = sqrt(sigma2e_B)) + mu_B Experiment <- as.factor(c(rep(\"A\", nA), rep(\"B\", nB))) dat4 <- data.frame(x = c(x1, x2), y = c(y1,y2), Experiment = Experiment) ggplot(dat4, aes(x = Experiment, y = y, fill = Experiment)) +     geom_boxplot() +    geom_point(position = position_jitterdodge(), alpha = 0.3) obj4 <- LMMsolve(fixed= y ~ 1,                   spline = ~spl1D(x, nseg = 50, xlim = c(0,1)),                  random = ~Experiment,                  residual = ~Experiment,                  data = dat4) summary(obj4) #> Table with effective dimensions and penalties:  #>  #>            Term Effective Model Nominal Ratio Penalty #>     (Intercept)      1.00     1       1  1.00    0.00 #>          lin(x)      1.00     1       1  1.00    0.00 #>      Experiment      0.93     2       1  0.93   77.97 #>            s(x)      7.89    53      51  0.15    0.00 #>  Experiment_A!R     43.66    50      50  0.87   32.15 #>  Experiment_B!R     95.52   100     100  0.96    9.01 #>  #>  Total Effective Dimension: 150 newdat <- data.frame(x=seq(0, 1, length = 300)) pred4 <- predict(obj4, newdata = newdat, se.fit = TRUE) pred4$y_true <- f2(pred4$x) ggplot(data = dat4, aes(x = x, y = y, colour = Experiment)) +   geom_point(size = 1.5) +   geom_line(data = pred4, aes(y = y_true), color=\"red\",              linewidth = 1, linetype = \"dashed\") +   geom_line(data = pred4, aes(y = ypred), color = \"blue\", linewidth = 1) +   geom_ribbon(data = pred4, aes(x = x,ymin = ypred-2*se, ymax = ypred+2*se),               alpha = 0.2, inherit.aes = FALSE) +    theme_bw() coef(obj4)$Experiment #> Experiment_A Experiment_B  #>   0.07719844  -0.07719844"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"smooth-trends-in-two-dimensions","dir":"Articles","previous_headings":"","what":"Smooth trends in two dimensions","title":"Mixed Models and Smoothing","text":"two-dimensional mixed P-splines defined Boer (2023) use two examples. first example US precipitation data. second example models data set Sea Surface Temperature (SST) described Cressie, Sainsbury-Dale, Zammit-Mangion (2022).","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"us-precipitation-example","dir":"Articles","previous_headings":"Smooth trends in two dimensions","what":"US precipitation example","title":"Mixed Models and Smoothing","text":"first example use USprecip data set spam package (Furrer Sain 2010), analysed Rodríguez-Álvarez et al. (2015). two-dimensional P-spline can defined spl2D() function, longitude latitude covariates. number segments chosen equal number segments used Rodríguez-Álvarez et al. (2015). summary function gives table effective dimensions penalty parameters: plot smooth trend can obtained similar way one-dimensional examples, using predict() function. First make predictions regular two-dimensional grid: plotting predictions USA main land use maps sf packages:","code":"## Get precipitation data from spam data(USprecip, package = \"spam\")  ## Only use observed data USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ] obj5 <- LMMsolve(fixed = anomaly ~ 1,                  spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                  data = USprecip) summary(obj5) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    302.60  1936    1932  0.16    0.26 #>         s(lat)    409.09  1936    1932  0.21    0.08 #>       residual   5190.31  5906    5902  0.88   13.53 #>  #>  Total Effective Dimension: 5906 lon_range <- range(USprecip$lon) lat_range <- range(USprecip$lat) newdat <- expand.grid(lon = seq(lon_range[1], lon_range[2], length = 200),                       lat = seq(lat_range[1], lat_range[2], length = 300)) plotDat5 <- predict(obj5, newdata = newdat) plotDat5 <- sf::st_as_sf(plotDat5, coords = c(\"lon\", \"lat\")) usa <- sf::st_as_sf(maps::map(\"usa\", regions = \"main\", plot = FALSE)) sf::st_crs(usa) <- sf::st_crs(plotDat5) intersection <- sf::st_intersects(plotDat5, usa) plotDat5 <- plotDat5[!is.na(as.numeric(intersection)), ]  ggplot(usa) +    geom_sf(color = NA) +   geom_tile(data = plotDat5,              mapping = aes(geometry = geometry, fill = ypred),              linewidth = 0,             stat = \"sf_coordinates\") +   scale_fill_gradientn(colors = topo.colors(100))+   labs(title = \"Precipitation (anomaly)\",         x = \"Longitude\", y = \"Latitude\") +   coord_sf() +   theme(panel.grid = element_blank())"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"sea-surface-temperatures","dir":"Articles","previous_headings":"Smooth trends in two dimensions","what":"Sea Surface Temperatures","title":"Mixed Models and Smoothing","text":"second example using two-dimensional P-splines Sea Surface Temperatures (SST) data (Cressie, Sainsbury-Dale, Zammit-Mangion 2022). study compare wide range software packages analyse SST data. comparison focus region ocean known Brazil-Malvinas confluence zone, energetic region ocean just coast Argentina Uruguay, warm Brazil current cold Malvinas current meet (Cressie, Sainsbury-Dale, Zammit-Mangion 2022). divided data within region training testing data set, consisting approximately 8,000 observations. First convert SST Kelvin Celsius split data training test set: next plot shows raw data, using color palette Cressie, Sainsbury-Dale, Zammit-Mangion (2022).  complicated data need segments spl2D() previous example, strong local changes Sea Surface Temperatures region. predictions grid shown next figure  standard errors predictions column se data frame pred_grid can plotted using following code:  Predictions test set given  Calculation root mean squared prediction error (RMSPE) test set: RMSPE range (0.44-0.46) software packages used Cressie, Sainsbury-Dale, Zammit-Mangion (2022). standard desktop calculations using LMMsolver take less 10 seconds, taking advantage sparse structure P-splines mixed model (Boer 2023).","code":"data(SeaSurfaceTemp) head(SeaSurfaceTemp, 5) #>        lon      lat    sst  type #> 1 -51.5607 -38.2629 289.94 train #> 2 -55.0255 -49.3163 278.60 train #> 3 -48.4228 -35.7470 291.51 train #> 4 -48.7221 -44.2118 282.78 train #> 5 -54.5217 -47.3870 282.44 train table(SeaSurfaceTemp$type) #>  #>  test train  #>  7894  7713 # convert from Kelvin to Celsius df <- SeaSurfaceTemp df$sst <- df$sst - 273.15 ### split in training and test set df_train <- df[df$type == \"train\", ] df_test <- df[df$type == \"test\", ] nasa_palette <- c(   \"#03006d\",\"#02008f\",\"#0000b6\",\"#0001ef\",\"#0000f6\",\"#0428f6\",\"#0b53f7\",   \"#0f81f3\",\"#18b1f5\",\"#1ff0f7\",\"#27fada\",\"#3efaa3\",\"#5dfc7b\",\"#85fd4e\",   \"#aefc2a\",\"#e9fc0d\",\"#f6da0c\",\"#f5a009\",\"#f6780a\",\"#f34a09\",\"#f2210a\",   \"#f50008\",\"#d90009\",\"#a80109\",\"#730005\" )  map_layer <- geom_map(   data = map_data(\"world\"), map = map_data(\"world\"),   aes(group = group, map_id = region),   fill = \"black\", colour = \"white\", linewidth = 0.1 )  # Brazil-Malvinas confluence zone BM_box <- cbind(lon = c(-60, -48), lat = c(-50, -35))  ggplot() +   scale_colour_gradientn(colours = nasa_palette, name = expression(degree*C)) +   xlab(\"Longitude (deg)\") + ylab(\"Latitude (deg)\") +   map_layer + xlim(BM_box[, \"lon\"]) + ylim(BM_box[, \"lat\"]) + theme_bw() +   coord_fixed(expand = FALSE) +   geom_point(data = df_train, aes(lon, lat, colour = sst), size=0.5) obj6 <- LMMsolve(fixed = sst ~ 1,                   spline = ~spl2D(lon, lat, nseg = c(70, 70),                                  x1lim = BM_box[, \"lon\"], x2lim = BM_box[, \"lat\"]),                  data = df_train, tolerance = 1.0e-1) summary(obj6) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    755.49  5329    5325  0.14    0.00 #>         s(lat)    689.68  5329    5325  0.13    0.00 #>       residual   6263.84  7713    7709  0.81    6.65 #>  #>  Total Effective Dimension: 7713 lon_range <- BM_box[, \"lon\"] lat_range <- BM_box[, \"lat\"] newdat <- expand.grid(lon = seq(lon_range[1], lon_range[2], length = 200),                       lat = seq(lat_range[1], lat_range[2], length = 200))  pred_grid <- predict(obj6, newdata = newdat, se.fit=TRUE) pred_grid <- pred_grid[pred_grid$se<5, ]  ## Plot predictions on a grid ggplot(pred_grid) +   geom_tile(aes(x = lon, y = lat, fill = ypred)) +   scale_fill_gradientn(colours = nasa_palette) +   labs(     fill = \"pred.\",     x = \"Longitude (deg)\", y = \"Latitude (deg)\"   ) +   map_layer +   theme_bw() +   coord_fixed(expand = FALSE, xlim = BM_box[, \"lon\"], ylim = BM_box[, \"lat\"]) +   scale_x_continuous(breaks = c(-58, -54, -50)) ## Plot standard error ggplot(pred_grid) +    geom_raster(aes(x = lon, y = lat, fill = se)) +    scale_fill_distiller(palette = \"BrBG\", direction = -1) +    labs( fill = \"s.e.\", x = \"Longitude (deg)\", y = \"Latitude (deg)\") +    map_layer +    theme_bw() +    coord_fixed(expand = FALSE, xlim = c(-60, -48), ylim = c(-50, -35)) +    scale_x_continuous(breaks = c(-58, -54, -50)) pred_test <- predict(obj6, newdata = df_test) ggplot(pred_test, aes(x = sst,y = ypred)) + geom_point() +      xlab(\"observed SST (Celsius)\") + ylab(\"predicted SST (Celsius)\") +      geom_abline(intercept=0,slope=1,col='red') + theme_bw() Y <- (pred_test$sst - pred_test$ypred)^2 RMSE <- sqrt(mean(Y)) round(RMSE, 2) #> [1] 0.45"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"generalized-linear-mixed-models-","dir":"Articles","previous_headings":"","what":"Generalized Linear Mixed Models.","title":"Mixed Models and Smoothing","text":"LMMsolver package can also used non-gaussian data, using family argument, default family = gaussian(). section give three examples. first example simulated count data following Poisson distribution. second example data following binomial distribution. final example categorical data using family = multinomial(), generalization binomial distribution.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"modelling-count-data-using-poisson-model-","dir":"Articles","previous_headings":"Generalized Linear Mixed Models.","what":"Modelling count data using Poisson model.","title":"Mixed Models and Smoothing","text":"example use count data using Poisson distribution, defined Pr(X=k)=λke−λk!,     \\Pr(X=k) = \\frac{\\lambda^k e^{-\\lambda}}{k!} \\;,  parameter λ>0\\lambda > 0 kk number occurrences. general, value parameter λ\\lambda can depend another variable xx, example time. assume xx defined interval [0,1][0,1] defined : λ(x)=4+3x+4sin(7x)   \\lambda(x) = 4 + 3x + 4 \\sin(7 x)  Using function simulate following data Now fit data argument family = poisson(): Making predictions plotting data similar Gaussian data showed :","code":"set.seed(1234) n <- 150 x <- seq(0, 1, length=n) fun_lambda <- function(x) { 4 + 3*x + 4*sin(7*x) } x <- seq(0, 1, length = n) y <- rpois(n = n, lambda = fun_lambda(x))  dat3 <- data.frame(x = x, y = y) obj3 <- LMMsolve(fixed = y ~ 1,                  spline = ~spl1D(x, nseg = 50),                  family = poisson(),                  data = dat3) summary(obj3) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00       0 #>       lin(x)      1.00     1       1  1.00       0 #>         s(x)      6.54    53      51  0.13       0 #>     residual    141.46   150     148  0.96       1 #>  #>  Total Effective Dimension: 150 newdat <- data.frame(x = seq(0, 1, length = 300)) pred3 <- predict(obj3, newdata = newdat, se.fit = TRUE) pred3$y_true <- fun_lambda(pred3$x)  ggplot(data = dat3, aes(x = x, y = y)) +   geom_point(col = \"black\", size = 1.5) +   geom_line(data = pred3, aes(y = y_true), color = \"red\",              linewidth = 1, linetype =\"dashed\") +   geom_line(data = pred3, aes(y = ypred), color = \"blue\", linewidth = 1) +   geom_ribbon(data= pred3, aes(x=x, ymin = ypred-2*se, ymax = ypred+2*se),               alpha=0.2, inherit.aes = FALSE) +   theme_bw()"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"binomial-distribution","dir":"Articles","previous_headings":"Generalized Linear Mixed Models.","what":"Binomial distribution","title":"Mixed Models and Smoothing","text":"binomial distribution given : Pr(X=k)=n!k!(n−k)!pn(1−p)n−k,     \\Pr(X=k) = \\frac{n!}{k! (n-k)!} p^{n} (1-p)^{n-k} \\;,  nn number observations, pp probability succes per observation, kk number successes (n−kn-k failures). Similar previous section assume probability pp non-linear function xx (x∈[0,1]x \\[0,1]) p(x)=0.5+0.4sin(2πx)   p(x) = 0.5 + 0.4 \\sin(2 \\pi x)  following code simulates data: Next can analyse data using family = binomial(), response using cbind(succes, failure): Making predictions can done shown examples: Finally, next R-chunk generates figure, black points fraction successes, red dashed curve true probability, blue curve predictions:","code":"set.seed(1234) n <- 100 sz <- 10  fun_prob <- function(x) { 0.5 + 0.4*sin(2*pi*x) }  x <- seq(0, 1, length=n) nsucces <- sapply(x, FUN=function(x) {                   rbinom(n=1, size = sz, prob = fun_prob(x))                 }) dat <- data.frame(x = x, succes = nsucces,                           failure= sz - nsucces) head(dat, 5) #>            x succes failure #> 1 0.00000000      3       7 #> 2 0.01010101      5       5 #> 3 0.02020202      5       5 #> 4 0.03030303      5       5 #> 5 0.04040404      4       6 obj3 <- LMMsolve(fixed = cbind(succes, failure) ~ 1,                  spline = ~spl1D(x, nseg = 50),                  family = binomial(),                  data = dat) summary(obj3) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00       0 #>       lin(x)      1.00     1       1  1.00       0 #>         s(x)      5.85    53      51  0.11       0 #>     residual     92.15   100      98  0.94       1 #>  #>  Total Effective Dimension: 100 newdat <- data.frame(x = seq(0, 1, by=0.01)) pred3 <- predict(obj3, newdata = newdat, se.fit=TRUE) pred3$y_true <- fun_prob(pred3$x) dat$y <- dat$succes/sz  ggplot(data = dat, aes(x = x, y = y)) +   geom_point(col = \"black\", size = 1.5) +   geom_line(data = pred3, aes(y = y_true), color = \"red\",             linewidth = 1, linetype = \"dashed\") +   geom_line(data = pred3, aes(y = ypred), color = \"blue\", linewidth = 1) +   geom_ribbon(data= pred3, aes(x=x, ymin = ypred-2*se, ymax = ypred+2*se),               alpha=0.2, inherit.aes = FALSE) +   theme_bw()"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"multinomial-distribution","dir":"Articles","previous_headings":"Generalized Linear Mixed Models.","what":"Multinomial distribution","title":"Mixed Models and Smoothing","text":"multinomial distribution generalization binomial distribution. fitting multinomial responses complicated standard GLMMs, details see Fahrmeir et al. (2013). kk categories : Pr(X1=x1,X2=x2,…,Xk=xk)=n!x1!x2!⋯xk!p1x1⋅p2x2⋯pkxk,     \\Pr(X_1=x_1,X_2=x_2, \\ldots, X_k = x_k) = \\frac{n!}{x_1! x_2! \\cdots x_k!} p_1^{x_1} \\cdot p_2^{x_2} \\cdots p_k^{x_k} \\;,  ∑=1kpi=1\\sum_{=1}^k p_i = 1 ∑=1kxi=n\\sum_{=1}^k x_i = n. following give example four categories (, B, C, D), probabilities pip_i depend single variable xx: Next simulate data: predictions given : following code generates plot prediction, points observed fractions, dashed curves true probabilities solid curves predicted values:","code":"k <- 4 mu <- c(0.1, 0.4, 0.6, 0.9) names(mu) <- LETTERS[1:k]  nonlinear <- function(x, mu) {   z <- sapply(mu, function(mu) { exp(-8*sin(pi*(x-mu))^2)})   # normalize to sum equal to one   z <- z/sum(z)   return(z) } x <- runif(n, 0, 1)    sz <- 10  multiNom <- t(sapply(x, FUN=                       function(x) {                         rmultinom(n=1, size=sz, prob = nonlinear(x,mu))                       } )) colnames(multiNom) <- names(mu) dat <- data.frame(x, multiNom) head(dat, 4) #>            x  A B C D #> 1 0.03545673  7 0 0 3 #> 2 0.56507611  0 1 9 0 #> 3 0.28025778  2 8 0 0 #> 4 0.20419632 10 0 0 0 obj <- LMMsolve(fixed = cbind(A,B,C,D) ~ 1,                 spline = ~spl1D(x, nseg = 17, xlim = c(0,1)),                 data = dat,                  family = multinomial()) summary(obj) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      3.00     3       3  1.00       0 #>       lin(x)      3.00     3       3  1.00       0 #>         s(x)      6.03    60      54  0.11       0 #>     residual    287.97   300     294  0.98       1 #>  #>  Total Effective Dimension: 300 sRows <- rowSums(multiNom) fr <- multiNom/sRows dat_fr <- data.frame(x, fr)  x0 <- seq(0, 1, by = 0.01) newdat <- data.frame(x = x0) pred <- predict(obj, newdata = newdat) head(pred) #>      x category     ypred #> 1 0.00        A 0.9051117 #> 2 0.01        A 0.9117668 #> 3 0.02        A 0.9178041 #> 4 0.03        A 0.9231971 #> 5 0.04        A 0.9279194 #> 6 0.05        A 0.9319405 library(tidyr) colnames(pred) <- c(\"x\", \"category\", \"y\") prob_true <- t(sapply(X=x0, FUN = function(x) { nonlinear(x, mu)})) colnames(prob_true) <- names(mu) df_true <- data.frame(x = x0, prob_true) prob_true_lf <- df_true %>% gather(key = \"category\",value=\"y\", A:D) dat_fr_lf <- dat_fr %>% gather(key = \"category\",value=\"y\", A:D) p1 <- ggplot(prob_true_lf, aes(x = x, y=y, color = category)) +   geom_line(linetype='dashed') +   geom_line(data=pred) +   geom_point(data=dat_fr_lf) p1"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"examples-from-quantitative-genetics","dir":"Articles","previous_headings":"","what":"Examples from Quantitative Genetics","title":"Mixed Models and Smoothing","text":"section show examples quantitative genetics, illustrate options package.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"oats-field-trial","dir":"Articles","previous_headings":"Examples from Quantitative Genetics","what":"Oats field trial","title":"Mixed Models and Smoothing","text":"first example use oats field trial agridat package. 24 varieties 3 replicates, consisting 6 incomplete blocks 4 plots. plots laid single row. use Linear Variance (LV) model, closely connected P-splines model (Boer, Piepho, Williams 2020). First need define precision matrix LV model, see Appendix Boer, Piepho, Williams (2020) details: Given precision matrix LV model can define model LMMsolve using random ginverse arguments: absolute deviance (−2*logL-2*logL) variances LV-model reported Boer, Piepho, Williams (2020), Table 1.","code":"## Load data. data(john.alpha, package = \"agridat\") head(john.alpha) #>   plot rep block gen  yield row col #> 1    1  R1    B1 G11 4.1172   1   1 #> 2    2  R1    B1 G04 4.4461   2   1 #> 3    3  R1    B1 G05 5.8757   3   1 #> 4    4  R1    B1 G22 4.5784   4   1 #> 5    5  R1    B2 G21 4.6540   5   1 #> 6    6  R1    B2 G10 4.1736   6   1 ## Add plot as factor. john.alpha$plotF <- as.factor(john.alpha$plot) ## Define the precision matrix, see eqn (A2) in Boer et al (2020). N <- nrow(john.alpha) cN <- c(1 / sqrt(N - 1), rep(0, N - 2), 1 / sqrt(N - 1)) D <- diff(diag(N), diff = 1) Delta <- 0.5 * crossprod(D) LVinv <- 0.5 * (2 * Delta + cN %*% t(cN)) ## Add LVinv to list, with name corresponding to random term. lGinv <- list(plotF = LVinv) obj7 <- LMMsolve(fixed = yield ~ rep + gen,                  random = ~plotF,                   ginverse = lGinv,                   data = john.alpha) round(deviance(obj7, relative = FALSE), 2) #> [1] 54.49 summary(obj7, which = \"variances\") #> Table with variances:  #>  #>   VarComp Variance #>     plotF     0.01 #>  residual     0.06"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"model-biomass-as-function-of-time-","dir":"Articles","previous_headings":"Examples from Quantitative Genetics","what":"Model biomass as function of time.","title":"Mixed Models and Smoothing","text":"section show example mixed model P-splines fit biomass function time. example use wheat data simulated crop growth model APSIM. data set included package. details simulated data see Bustos-Korts et al. (2019). first column environment, Emerald 1993, second column simulated genotype (g001), third column days sowing (das), last column simulated biomass medium measurement error. model can fitted effective dimensions : fitted smooth trend can obtained explained :  growth rate (first derivative) function time can obtained using deriv = 1 function obtainSmoothTrend:","code":"data(APSIMdat) head(APSIMdat) #>            env geno das   biomass #> 1 Emerald_1993 g001  20  65.57075 #> 2 Emerald_1993 g001  21  60.70499 #> 3 Emerald_1993 g001  22  74.06247 #> 4 Emerald_1993 g001  23  63.73951 #> 5 Emerald_1993 g001  24 101.88005 #> 6 Emerald_1993 g001  25  96.84971 obj8 <- LMMsolve(fixed = biomass ~ 1,                  spline = ~spl1D(x = das, nseg = 50),                   data = APSIMdat) summary(obj8) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00    0.00 #>     lin(das)      1.00     1       1  1.00    0.00 #>       s(das)      6.46    53      51  0.13    0.01 #>     residual    112.54   121     119  0.95    0.00 #>  #>  Total Effective Dimension: 121 das_range <- range(APSIMdat$das) newdat <- data.frame(das=seq(das_range[1], das_range[2], length = 300)) pred8 <- predict(obj8, newdata = newdat, se.fit = TRUE) ggplot(data = APSIMdat, aes(x = das, y = biomass)) +   geom_point(size = 1.0) +   geom_line(data = pred8, aes(y = ypred), color = \"blue\", linewidth = 1) +   geom_ribbon(data = pred8, aes(x = das,ymin = ypred-2*se, ymax = ypred+2*se),               alpha = 0.2, inherit.aes = FALSE) +      labs(title = \"APSIM biomass as function of time\",         x = \"days after sowing\", y = \"biomass (kg)\") +   theme_bw() plotDatDt <- obtainSmoothTrend(obj8, grid = 1000, deriv = 1)  ggplot(data = plotDatDt, aes(x = das, y = ypred)) +   geom_line(color = \"red\", linewidth = 1) +   labs(title = \"APSIM growth rate as function of time\",         x = \"days after sowing\", y = \"growth rate (kg/day)\") +   theme_bw()"},{"path":"https://biometris.github.io/LMMsolver/index.html/articles/Solving_Linear_Mixed_Models.html","id":"qtl-mapping-with-ibd-probabilities-","dir":"Articles","previous_headings":"Examples from Quantitative Genetics","what":"QTL mapping with IBD probabilities.","title":"Mixed Models and Smoothing","text":"QTL-mapping multiparental populations Identity--Descent (IBD) probabilities used genetic predictors mixed model (Li et al. 2021). following simulated example illustration. consists three parents (, B, C), two crosses AxB, AxC. AxB population 100 Doubled Haploids (DH), AxC 80 DHs. probabilities, pA, pB, pC, position genome close simulated QTL. simulated data included package. residual (genetic) variances two populations can different. Therefore need allow heterogeneous residual variances, can defined using residual argument LMMsolve: QTL-probabilities defined columns pA, pB, pC, can included random part mixed model using group argument: approximate −log10(p)-log10(p) value given estimated QTL effects parents , B, C given :","code":"## Load data for multiparental population. data(multipop) head(multipop) #>   cross     ind         pA         pB pC    pheno #> 1   AxB AxB0001 0.17258816 0.82741184  0 9.890637 #> 2   AxB AxB0002 0.82170793 0.17829207  0 6.546568 #> 3   AxB AxB0003 0.95968439 0.04031561  0 7.899249 #> 4   AxB AxB0004 0.96564081 0.03435919  0 4.462866 #> 5   AxB AxB0005 0.04838734 0.95161266  0 5.207757 #> 6   AxB AxB0006 0.95968439 0.04031561  0 5.265580 ## Fit null model. obj9 <- LMMsolve(fixed = pheno ~ cross,                   residual = ~cross,                   data = multipop) dev0 <- deviance(obj9, relative = FALSE) ## Fit alternative model - include QTL with probabilities defined in columns 3:5  lGrp <- list(QTL = 3:5) obj10 <- LMMsolve(fixed = pheno ~ cross,                   group = lGrp,                  random = ~grp(QTL),                  residual = ~cross,                  data = multipop)  dev1 <- deviance(obj10, relative = FALSE) ## Deviance difference between null and alternative model. dev <- dev0 - dev1 ## Calculate approximate p-value.  minlog10p <- -log10(0.5 * pchisq(dev, 1, lower.tail = FALSE)) round(minlog10p, 2) #> [1] 8.76 coef(obj10)$QTL #>     QTL_pA     QTL_pB     QTL_pC  #> -1.2676362  0.6829275  0.5847088"},{"path":[]},{"path":"https://biometris.github.io/LMMsolver/index.html/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Martin Boer. Author. Bart-Jan van Rossum. Author, maintainer.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Martin P. Boer (2023). Tensor product P-splines using sparse mixed model formulation Statistical Modelling 23 465 - 479 URL https://doi.org/10.1177/1471082X231178591","code":"@Article{,   title = {Tensor product {P}-splines using a sparse mixed model formulation},   author = {{Martin P. Boer}},   journal = {Statistical Modelling},   year = {2023},   volume = {23},   number = {5-6},   pages = {465 - 479},   doi = {10.1177/1471082X231178591}, }"},{"path":"https://biometris.github.io/LMMsolver/index.html/index.html","id":"lmmsolver-","dir":"","previous_headings":"","what":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"aim LMMsolver package provide efficient flexible system estimate variance components using restricted maximum likelihood REML (Patterson Thompson 1971), models mixed model equations sparse. important feature package smoothing P-splines (Eilers Marx 1996). sparse mixed model P-splines formulation (Boer 2023) used, makes computations fast. computational advantage sparse mixed model formulation especially clear two-dimensional smoothing (Boer 2023; Carollo et al. 2024).","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"Install CRAN: Install latest development version GitHub (requires remotes package):","code":"install.packages(\"LMMsolver\") remotes::install_github(\"Biometris/LMMsolver\", ref = \"develop\", dependencies = TRUE)"},{"path":"https://biometris.github.io/LMMsolver/index.html/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"An R package for providing an efficient and flexible system to solve sparse mixed model equations","text":"example functionality package use USprecip data set spam package (Furrer Sain 2010). two-dimensional P-spline can defined spl2D() function, longitude latitude covariates, anomaly (standardized monthly total precipitation) response variable: spatial trend precipitation can now plotted map USA, using predict function LMMsolver:  examples can found vignette.","code":"library(LMMsolver) library(ggplot2)  ## Get precipitation data from spam data(USprecip, package = \"spam\")  ## Only use observed data. USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ] head(USprecip[, c(1, 2, 4)], 3) #>      lon   lat  anomaly #> 6 -85.95 32.95 -0.84035 #> 7 -85.87 32.98 -0.65922 #> 9 -88.28 33.23 -0.28018 obj1 <- LMMsolve(fixed = anomaly ~ 1,                  spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                  data = USprecip) lon_range <- range(USprecip$lon) lat_range <- range(USprecip$lat) newdat <- expand.grid(lon = seq(lon_range[1], lon_range[2], length = 200),                       lat = seq(lat_range[1], lat_range[2], length = 300)) plotDat <- predict(obj1, newdata = newdat)  plotDat <- sf::st_as_sf(plotDat, coords = c(\"lon\", \"lat\")) usa <- sf::st_as_sf(maps::map(\"usa\", regions = \"main\", plot = FALSE)) sf::st_crs(usa) <- sf::st_crs(plotDat) intersection <- sf::st_intersects(plotDat, usa) plotDat <- plotDat[!is.na(as.numeric(intersection)), ]  ggplot(usa) +    geom_sf(color = NA) +   geom_tile(data = plotDat,              mapping = aes(geometry = geometry, fill = ypred),              linewidth = 0,             stat = \"sf_coordinates\") +   scale_fill_gradientn(colors = topo.colors(100))+   labs(title = \"Precipitation (anomaly)\",         x = \"Longitude\", y = \"Latitude\") +   coord_sf() +   theme(panel.grid = element_blank()) vignette(\"Solving_Linear_Mixed_Models\")"},{"path":[]},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/ADchol.html","id":null,"dir":"Reference","previous_headings":"","what":"construct object for Automated Differentiation Cholesky decomposition — ADchol","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"Construct object reverse Automated Differentiation Cholesky decomposition, input list semi-positive symmetric sparse matrices \\(P_i\\), dimension \\(q \\times q\\). function ADchol calculates matrix \\(C\\), sum precision matrices \\(P_i\\): \\(C = \\sum_{}  P_i\\). Next, calculates Cholesky Decomposition using multiple minimum degree (MMD) algorithm spam package.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/ADchol.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"","code":"ADchol(lP)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/ADchol.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"lP list symmetric matrices class spam, dimension \\(q \\times q\\), sum matrices assumed positive definite.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/ADchol.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"object class ADchol. object used calculate partial partial derivatives \\(log|C|\\) efficient way.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/ADchol.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"construct object for Automated Differentiation Cholesky decomposition — ADchol","text":"Furrer, R., & Sain, S. R. (2010). spam: sparse matrix R package emphasis MCMC methods Gaussian Markov random fields. Journal Statistical Software, 36, 1-25.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/APSIMdat.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"Simulated Biomass function time using APSIM wheat.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/APSIMdat.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"","code":"APSIMdat"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/APSIMdat.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"data.frame 121 rows 4 columns. env Environment, Emerald 1993 geno Simulated genotype g001 das Days sowing biomass Simulated biomass using APSIM; medium measurement error added","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/APSIMdat.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulated Biomass as function of time using APSIM wheat. — APSIMdat","text":"Bustos-Korts et al. (2019) Combining Crop Growth Modeling Statistical Genetic Modeling Evaluate Phenotyping Strategies doi:10.3389/FPLS.2019.01491","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/Bsplines.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct design matrix for B-Splines — Bsplines","title":"Construct design matrix for B-Splines — Bsplines","text":"Construct design matrix B-Splines.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/Bsplines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct design matrix for B-Splines — Bsplines","text":"","code":"Bsplines(knots, x, deriv = 0)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/Bsplines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct design matrix for B-Splines — Bsplines","text":"knots numerical vector knot positions. x numeric vector values evaluate B-spline functions derivatives. deriv numerical value. derivative given order evaluated x positions.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Solve Linear Mixed Models — LMMsolve","title":"Solve Linear Mixed Models — LMMsolve","text":"Solve Linear Mixed Models using REML.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Solve Linear Mixed Models — LMMsolve","text":"","code":"LMMsolve(   fixed,   random = NULL,   spline = NULL,   group = NULL,   ginverse = NULL,   weights = NULL,   data,   residual = NULL,   family = gaussian(),   offset = 0,   tolerance = 1e-06,   trace = FALSE,   maxit = 250,   theta = NULL,   grpTheta = NULL )"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Solve Linear Mixed Models — LMMsolve","text":"fixed formula fixed part model. form \"response ~ pred\" random formula random part model. form \"~ pred\". spline formula spline part model. form \"~ spl1D()\", ~ spl2D()\" \"~spl3D()\". Generalized Additive Models (GAMs) can also used, example \"~ spl1D() + spl2D()\" group named list component numeric vector specifying contiguous fields data considered single term. ginverse named list component symmetric matrix, precision matrix corresponding random term model. row column order precision matrices match order levels corresponding factor data. weights character string identifying column data use relative weights fit. Default value NULL, weights equal one. data data.frame containing modeling data. residual formula residual part model. form \"~ pred\". family object class family familyLMMsolver specifying distribution link function. See class family multinomial details. offset priori known component included linear predictor fitting. Offset numeric vector, character string identifying column data. Default offset = 0. tolerance numerical value. convergence tolerance modified Henderson algorithm estimate variance components. trace progress algorithm printed? Default trace = FALSE. maxit numerical value. maximum number iterations algorithm. Default maxit = 250. theta initial values penalty precision parameters. Default NULL, precision parameters set equal 1. grpTheta vector give components penalty. Default NULL, components separate penalty.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Solve Linear Mixed Models — LMMsolve","text":"object class LMMsolve representing fitted model. See LMMsolveObject full description components object.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Solve Linear Mixed Models — LMMsolve","text":"Linear Mixed Model (LMM) form $$y = X \\beta + Z u + e, u \\sim N(0,G), e \\sim N(0,R)$$ \\(y\\) vector observations, \\(\\beta\\) vector fixed effects, \\(u\\) vector random effects, \\(e\\) vector random residuals. \\(X\\) \\(Z\\) design matrices. LMMsolve can fit models matrices \\(G^{-1}\\) \\(R^{-1}\\) linear combination precision matrices \\(Q_{G,}\\) \\(Q_{R,}\\): $$G^{-1} = \\sum_{} \\psi_i Q_{G,} \\;, R^{-1} = \\sum_{} \\phi_i Q_{R,}$$ precision parameters \\(\\psi_i\\) \\(\\phi_i\\) estimated using REML. standard mixed models \\(1/{\\psi_i}\\) variance components \\(1/{\\phi_i}\\) residual variances. use formulation terms precision parameters allow non-standard mixed models using tensor product splines.","code":""},{"path":[]},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Solve Linear Mixed Models — LMMsolve","text":"","code":"## Fit models on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Fit the same model with genotype as random effect. LMM1_rand <- LMMsolve(fixed = yield ~ rep,                      random = ~gen,                      data = john.alpha)  ## Fit the model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  ## Fit models on multipop data included in the package. data(multipop)  ## The residual variances for the two populations can be different. ## Allow for heterogeneous residual variances using the residual argument. LMM2 <- LMMsolve(fixed = pheno ~ cross,                 residual = ~cross,                 data = multipop)  ## QTL-probabilities are defined by the columns pA, pB, pC. ## They can be included in the random part of the model by specifying the ## group argument and using grp() in the random part.  # Define groups by specifying columns in data corresponding to groups in a list. # Name used in grp() should match names specified in list. lGrp <- list(QTL = 3:5) LMM2_group <- LMMsolve(fixed = pheno ~ cross,                       group = lGrp,                       random = ~grp(QTL),                       residual = ~cross,                       data = multipop)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolveObject.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted LMMsolve Object — LMMsolveObject","title":"Fitted LMMsolve Object — LMMsolveObject","text":"object class LMMsolve returned LMMsolve function, representing fitted linear mixed model. Objects class methods generic functions coef, fitted, residuals, loglik deviance.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolveObject.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted LMMsolve Object — LMMsolveObject","text":"object class LMMsolve contains following components: logL restricted log-likelihood convergence sigma2e residual error tau2e estimated variance components EDdf effective dimensions varPar number variance parameters variance component VarDf table variance components theta precision parameters coefMME vector estimated effects mixed model equations ndxCoefficients indices coefficients names yhat fitted values residuals residuals nIter number iterations mixed model converge y Response variable X design matrix fixed part mixed model Z design matrix random part mixed model lGinv List precision matrices random terms lRinv List precision matrices residual C mixed model coefficient matrix last iteration cholC cholesky decomposition coefficient matrix C constantREML REML constant dim dimensions fixed random terms mixed model term.labels.f names fixed terms mixed model term.labels.r names random terms mixed model respVar name(s) response variable(s). splRes object definition spline argument deviance relative deviance family object class family specifying distribution link function trace data.frame convergence sequence log likelihood effective dimensions .","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolver.html","id":null,"dir":"Reference","previous_headings":"","what":"Package LMMsolver — LMMsolver","title":"Package LMMsolver — LMMsolver","text":"Linear Mixed Model Solver using sparse matrix algebra.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolver.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Package LMMsolver — LMMsolver","text":"efficient flexible system solve sparse mixed model equations, models often used statistical genetics. Important applications use splines model spatial temporal trends. Another application area mixed model QTL analysis multiparental populations, allowing heterogeneous residual variance random design matrices Identity--Descent (IBD) probabilities.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolver.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Package LMMsolver — LMMsolver","text":"Martin P. Boer (2023). Tensor product P-splines using sparse mixed model formulation, Statistical Modelling, 23, p. 465 - 479. doi:10.1177/1471082X231178591","code":""},{"path":[]},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/LMMsolver.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Package LMMsolver — LMMsolver","text":"Martin Boer martin.boer@wur.nl Bart-Jan van Rossum bart-jan.vanrossum@wur.nl (maintainer)","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/PsplinesKnots.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct equally placed knots — PsplinesKnots","title":"Construct equally placed knots — PsplinesKnots","text":"Construct equally placed knots.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/PsplinesKnots.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct equally placed knots — PsplinesKnots","text":"","code":"PsplinesKnots(xmin, xmax, degree, nseg)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/PsplinesKnots.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct equally placed knots — PsplinesKnots","text":"xmin numerical value. xmax numerical value. degree numerical value. nseg numerical value.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/PsplinesKnots.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct equally placed knots — PsplinesKnots","text":"numerical vector knot positions.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/RowKronecker.html","id":null,"dir":"Reference","previous_headings":"","what":"Row-wise kronecker product — RowKronecker","title":"Row-wise kronecker product — RowKronecker","text":"Row-wise kronecker product","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/RowKronecker.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Row-wise kronecker product — RowKronecker","text":"","code":"RowKronecker(X1, X2)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/RowKronecker.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Row-wise kronecker product — RowKronecker","text":"X1 matrix. X2 matrix.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/RowKronecker.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Row-wise kronecker product — RowKronecker","text":"row-wise kronecker product X1 X2.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/SeaSurfaceTemp.html","id":null,"dir":"Reference","previous_headings":"","what":"Sea Surface Temperature — SeaSurfaceTemp","title":"Sea Surface Temperature — SeaSurfaceTemp","text":"Sea Surface Temperature","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/SeaSurfaceTemp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sea Surface Temperature — SeaSurfaceTemp","text":"","code":"SeaSurfaceTemp"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/SeaSurfaceTemp.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sea Surface Temperature — SeaSurfaceTemp","text":"data.frame 15607 rows 4 columns. lon longitude lat latitude sst sea surface temperature Kelvin type defines training test set","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/SeaSurfaceTemp.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Sea Surface Temperature — SeaSurfaceTemp","text":"Cressie et al. (2022) Basis-function models spatial statistics. Annual Review Statistics Application. doi:10.1146/annurev-statistics-040120-020733","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/calcStandardErrors.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard errors for predictions — calcStandardErrors","title":"Standard errors for predictions — calcStandardErrors","text":"Calculates standard errors predictions \\(D \\hat{u}\\), see Welham et al. 2004 Gilmour et al. 2004 details.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/calcStandardErrors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard errors for predictions — calcStandardErrors","text":"","code":"calcStandardErrors(C, D)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/calcStandardErrors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standard errors for predictions — calcStandardErrors","text":"C symmetric matrix class spam D matrix class spam","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/calcStandardErrors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standard errors for predictions — calcStandardErrors","text":"vector standard errors predictions \\(D \\hat{u}\\).","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/calcStandardErrors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Standard errors for predictions — calcStandardErrors","text":"prediction error variance given \\(D C^{-1} D'\\), \\(C\\) mixed model coefficient matrix, \\(D\\) defines linear combinations fixed random effects. standard errors given square root diagonal. calculate standard errors efficient way use $$\\frac{\\partial log|C + \\xi_i d_i d_i'|}{\\partial \\xi_i} |_{\\xi_i=0}  = trace(C^{-1} d_i d_i') = trace(d_i' C^{-1} d_i) = d_i' C^{-1} d_i, $$ \\(d_i\\) row \\(\\) matrix \\(D\\). values \\(d_i' C^{-1} d_i\\) can calculated efficient, avoiding calculation inverse \\(C\\), using Automated Differentiation Choleksy algorithm, see section 2.3 Smith (1995) details.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/calcStandardErrors.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Standard errors for predictions — calcStandardErrors","text":"Welham, S., Cullis, B., Gogel, B., Gilmour, ., & Thompson, R. (2004). Prediction linear mixed models. Australian & New Zealand Journal Statistics, 46(3), 325-347. Smith, S. P. (1995). Differentiation Cholesky algorithm. Journal Computational Graphical Statistics, 4(2), 134-147. Gilmour, ., Cullis, B., Welham, S., Gogel, B., & Thompson, R. (2004). efficient computing strategy prediction mixed linear models. Computational statistics & data analysis, 44(4), 571-586.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/coef.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"Obtain coefficients mixed model equations LMMsolve object.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/coef.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"","code":"# S3 method for class 'LMMsolve' coef(object, se = FALSE, ...)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/coef.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"object object class LMMsolve se calculate standard errors, default FALSE. ... methods generic require additional arguments. None used method.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/coef.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"list vectors, containing estimated effects fixed effect predictions random effect defined linear mixed model.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/coef.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coefficients from the mixed model equations of an LMMsolve object. — coef.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain coefficients. coefs1 <- coef(LMM1)  ## Obtain coefficients with standard errors. coefs2 <- coef(LMM1, se = TRUE)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/constructRinv.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function for constructing Rinv — constructRinv","title":"Helper function for constructing Rinv — constructRinv","text":"Helper function constructing Rinv","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/constructRinv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function for constructing Rinv — constructRinv","text":"","code":"constructRinv(df, residual, weights)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/deviance.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Deviance of an LMMsolve object — deviance.LMMsolve","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"Obtain deviance model fitted using LMMsolve.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/deviance.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"","code":"# S3 method for class 'LMMsolve' deviance(object, relative = TRUE, includeConstant = TRUE, ...)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/deviance.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"object object class LMMsolve relative Deviance relative conditional absolute unconditional (-2*logLik(object))? Default relative = TRUE. includeConstant constant restricted log-likelihood included. Default TRUE, example lme4 SAS. asreml constant omitted. ... methods generic require additional arguments. None used method.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/deviance.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"deviance fitted model.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/deviance.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deviance of an LMMsolve object — deviance.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. deviance(LMM1) #> [1] 6.190954"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/diagnosticsMME.html","id":null,"dir":"Reference","previous_headings":"","what":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"Give diagnostics mixed model coefficient matrix C cholesky decomposition","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/diagnosticsMME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"","code":"diagnosticsMME(object)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/diagnosticsMME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"object object class LMMsolve.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/diagnosticsMME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"summary mixed model coefficient matrix choleski decomposition.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/diagnosticsMME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Give diagnostics for mixed model coefficient matrix C and the cholesky decomposition — diagnosticsMME","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. diagnosticsMME(LMM1) #> Summary of matrix C  #> Matrix object of class 'spam' of dimension 26x26, #>     with 168 (row-wise) nonzero elements. #>     Density of the matrix is 24.9%. #> Class 'spam' (32-bit) #>  #>  Summary of cholesky decomposition of C  #> Matrix object of class 'spam' of dimension 26x26, #>     with 98 (row-wise) nonzero elements. #>     Density of the matrix is 14.5%. #> Class 'spam' (32-bit)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/displayMME.html","id":null,"dir":"Reference","previous_headings":"","what":"Display the sparseness of the mixed model coefficient matrix — displayMME","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"Display sparseness mixed model coefficient matrix","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/displayMME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"","code":"displayMME(object, cholesky = FALSE)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/displayMME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"object object class LMMsolve. cholesky cholesky decomposition coefficient matrix plotted?","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/displayMME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"plot sparseness mixed model coefficient matrix.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/displayMME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display the sparseness of the mixed model coefficient matrix — displayMME","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain deviance. displayMME(LMM1)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/fitted.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitted values of an LMMsolve object. — fitted.LMMsolve","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"Obtain fitted values mixed model fitted using LMMSolve.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/fitted.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"","code":"# S3 method for class 'LMMsolve' fitted(object, ...)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/fitted.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"object object class LMMsolve ... methods generic require additional arguments. None used method.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/fitted.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"vector fitted values.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/fitted.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitted values of an LMMsolve object. — fitted.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain fitted values. fitted1 <- fitted(LMM1)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/logLik.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"Obtain Restricted Maximum Log-Likelihood model fitted using LMMsolve.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/logLik.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"","code":"# S3 method for class 'LMMsolve' logLik(object, includeConstant = TRUE, ...)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/logLik.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"object object class LMMsolve includeConstant constant restricted log-likelihood included. Default TRUE, example lme4 SAS. asreml constant omitted. ... methods generic require additional arguments. None used method.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/logLik.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"restricted maximum log-likelihood fitted model.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/logLik.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Log-likelihood of an LMMsolve object — logLik.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain log-likelihood. logLik(LMM1) #> [1] -34.95557  ## Obtain log-likelihood without constant. logLik(LMM1, includeConstant = FALSE) #> [1] 7.315605"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/multinomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Family Object for Multinomial Model — multinomial","title":"Family Object for Multinomial Model — multinomial","text":"Multinomial model part standard family. implementation based Chapter 6 Fahrmeir et al. (2013).","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/multinomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Family Object for Multinomial Model — multinomial","text":"","code":"multinomial()"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/multinomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Family Object for Multinomial Model — multinomial","text":"object class familyLMMsolver following components: family character string family name. linkfun link function. linkinv inverse link function. dev.resids function giving deviance observation function (y, mu, wt)","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/multinomial.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Family Object for Multinomial Model — multinomial","text":"Fahrmeir, Ludwig, Thomas Kneib, Stefan Lang, Brian Marx, Regression models. Springer Berlin Heidelberg, 2013.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/multipop.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulated QTL mapping data set — multipop","title":"Simulated QTL mapping data set — multipop","text":"Simulated QTL mapping data set","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/multipop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulated QTL mapping data set — multipop","text":"","code":"multipop"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/multipop.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Simulated QTL mapping data set — multipop","text":"data.frame 180 rows 6 columns. cross Cross ID, two populations, AxB AxC ind Genotype ID pA Probability individual alleles parent pB Probability individual alleles parent B pC Probability individual alleles parent C pheno Simulated phenotypic value","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/obtainSmoothTrend.html","id":null,"dir":"Reference","previous_headings":"","what":"Obtain Smooth Trend. — obtainSmoothTrend","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"Obtain smooth trend models fitted spline component.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/obtainSmoothTrend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"","code":"obtainSmoothTrend(   object,   grid = NULL,   newdata = NULL,   deriv = 0,   includeIntercept = FALSE,   which = 1 )"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/obtainSmoothTrend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"object object class LMMsolve. grid numeric vector length dimension fitted spline component. represents number grid points surface computed. newdata data.frame containing new points smooth trend computed. Column names include names used fitting spline model. deriv Derivative B-splines, default 0. moment implemented spl1D. includeIntercept value intercept included computed smooth trend? Ignored deriv > 0. integer, multiple splxD terms model. Default value 1.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/obtainSmoothTrend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"data.frame predictions smooth trend specified grid. standard errors saved `deriv` default value 0.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/obtainSmoothTrend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Obtain Smooth Trend. — obtainSmoothTrend","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit a model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  ## Obtain the smooth trend for the fitted model on a dense grid. smooth1 <- obtainSmoothTrend(LMM1_spline,                             grid = 100)  ## Obtain the smooth trend on a new data set - plots 10 to 40. newdat <- data.frame(plot = 10:40) smooth2 <- obtainSmoothTrend(LMM1_spline,                             newdata = newdat)  ## The first derivative of the smooth trend can be obtained by setting deriv = 1. smooth3 <- obtainSmoothTrend(LMM1_spline,                             grid = 100,                             deriv = 1)  ## For examples of higher order splines see the vignette."},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/predict.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict function — predict.LMMsolve","title":"Predict function — predict.LMMsolve","text":"Predict function","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/predict.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict function — predict.LMMsolve","text":"","code":"# S3 method for class 'LMMsolve' predict(object, ..., newdata, se.fit = FALSE)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/predict.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict function — predict.LMMsolve","text":"object object class LMMsolve. ... Unused. newdata data.frame containing new points smooth trend computed. Column names include names used fitting spline model. se.fit calculate standard errors, default FALSE.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/predict.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict function — predict.LMMsolve","text":"data.frame predictions smooth trend specified grid. standard errors saved `se.fit=TRUE`.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/predict.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict function — predict.LMMsolve","text":"","code":"## simulate some data f <- function(x) { 0.3 + 0.4*x + 0.2*sin(20*x) } set.seed(12) n <- 150 x <- seq(0, 1, length = n) sigma2e <- 0.04 y <- f(x) + rnorm(n, sd = sqrt(sigma2e)) dat <- data.frame(x, y)  ## fit the model obj <- LMMsolve(fixed = y ~ 1,          spline = ~spl1D(x, nseg = 50), data = dat)  ## make predictions on a grid newdat <- data.frame(x = seq(0, 1, length = 300)) pred <- predict(obj, newdata = newdat, se.fit = TRUE) head(pred) #>             x     ypred         se #> 1 0.000000000 0.2051355 0.09713998 #> 2 0.003344482 0.2170841 0.08941911 #> 3 0.006688963 0.2290119 0.08248844 #> 4 0.010033445 0.2409332 0.07639899 #> 5 0.013377926 0.2528619 0.07117904 #> 6 0.016722408 0.2648123 0.06680933"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/predictTest.html","id":null,"dir":"Reference","previous_headings":"","what":"Test function for predict, for the moment internal — predictTest","title":"Test function for predict, for the moment internal — predictTest","text":"Test function predict, moment internal","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/predictTest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test function for predict, for the moment internal — predictTest","text":"","code":"predictTest(object, classify)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/residuals.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Residuals of an LMMsolve object. — residuals.LMMsolve","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"Obtain residuals mixed model fitted using LMMSolve.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/residuals.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"","code":"# S3 method for class 'LMMsolve' residuals(object, ...)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/residuals.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"object object class LMMsolve ... methods generic require additional arguments. None used method.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/residuals.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"vector residuals.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/residuals.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Residuals of an LMMsolve object. — residuals.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain fitted values. residuals1 <- residuals(LMM1)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/spl1D.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit P-splines — spl1D","title":"Fit P-splines — spl1D","text":"Fit multi dimensional P-splines using sparse implementation.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/spl1D.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit P-splines — spl1D","text":"","code":"spl1D(   x,   nseg,   pord = 2,   degree = 3,   scaleX = TRUE,   xlim = range(x),   cond = NULL,   level = NULL )  spl2D(   x1,   x2,   nseg,   pord = 2,   degree = 3,   scaleX = TRUE,   x1lim = range(x1),   x2lim = range(x2),   cond = NULL,   level = NULL )  spl3D(   x1,   x2,   x3,   nseg,   pord = 2,   degree = 3,   scaleX = TRUE,   x1lim = range(x1),   x2lim = range(x2),   x3lim = range(x3) )"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/spl1D.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit P-splines — spl1D","text":"x, x1, x2, x3 variables data containing values x covariates. nseg number segments pord order penalty, default pord = 2 degree degree B-spline basis, default degree = 3 scaleX fixed effects scaled. xlim, x1lim, x2lim, x3lim numerical vector length 2 containing domain corresponding x covariate knots placed. Default set NULL, covariate range used. cond Conditional factor: splines defined conditional level. Default NULL. level level conditional factor. Default NULL.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/spl1D.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit P-splines — spl1D","text":"list following elements: X - design matrix fixed effect. intercept included. Z - design matrix random effect. lGinv - list precision matrices knots - list vectors knot positions dim.f - dimensions fixed effect. dim.r - dimensions random effect. term.labels.f - labels fixed effect terms. term.labels.r - labels random effect terms. x - list vectors spline variables. pord - order penalty. degree - degree B-spline basis. scaleX - logical indicating fixed effects scaled. EDnom - nominal effective dimensions.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/spl1D.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Fit P-splines — spl1D","text":"spl2D(): 2-dimensional splines spl3D(): 3-dimensional splines","code":""},{"path":[]},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/spl1D.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit P-splines — spl1D","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit a model with a 1-dimensional spline at the plot level. LMM1_spline <- LMMsolve(fixed = yield ~ rep + gen,                        spline = ~spl1D(x = plot, nseg = 20),                        data = john.alpha)  summary(LMM1_spline) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)      1.00     1       1  1.00    0.00 #>          rep      2.00     2       2  1.00    0.00 #>          gen     23.00    23      23  1.00    0.00 #>    lin(plot)      1.00     1       1  1.00    0.00 #>      s(plot)      3.99    23      21  0.19 3310.21 #>     residual     41.01    72      45  0.91   13.21 #>  #>  Total Effective Dimension: 72   ## Fit model on US precipitation data from spam package. data(USprecip, package = \"spam\")  ## Only use observed data USprecip <- as.data.frame(USprecip) USprecip <- USprecip[USprecip$infill == 1, ]  ## Fit a model with a 2-dimensional P-spline. LMM2_spline <- LMMsolve(fixed = anomaly ~ 1,                        spline = ~spl2D(x1 = lon, x2 = lat, nseg = c(41, 41)),                        data = USprecip)  summary(LMM2_spline) #> Table with effective dimensions and penalties:  #>  #>           Term Effective Model Nominal Ratio Penalty #>    (Intercept)      1.00     1       1  1.00    0.00 #>  lin(lon, lat)      3.00     3       3  1.00    0.00 #>         s(lon)    302.60  1936    1932  0.16    0.26 #>         s(lat)    409.09  1936    1932  0.21    0.08 #>       residual   5190.31  5906    5902  0.88   13.53 #>  #>  Total Effective Dimension: 5906"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/summary.LMMsolve.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Linear Mixed Model fits — summary.LMMsolve","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"Summary method class \"LMMsolve\". Creates either table effective dimensions (= \"dimensions\") table variances (= \"variances\").","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/summary.LMMsolve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"","code":"# S3 method for class 'LMMsolve' summary(object, which = c(\"dimensions\", \"variances\"), ...)  # S3 method for class 'summary.LMMsolve' print(x, ...)"},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/summary.LMMsolve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"object object class LMMsolve character string indicating summary table created. ... methods generic require additional arguments. None used method. x object class summary.LMMsolve, result call summary.LMM","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/summary.LMMsolve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"data.frame either effective dimensions variances depending .","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/summary.LMMsolve.html","id":"methods-by-generic-","dir":"Reference","previous_headings":"","what":"Methods (by generic)","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"print(summary.LMMsolve): print summary","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/reference/summary.LMMsolve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Linear Mixed Model fits — summary.LMMsolve","text":"","code":"## Fit model on john.alpha data from agridat package. data(john.alpha, package = \"agridat\")  ## Fit simple model with only fixed effects. LMM1 <- LMMsolve(fixed = yield ~ rep + gen,                 data = john.alpha)  ## Obtain table of effective dimensions. summ1 <- summary(LMM1) print(summ1) #> Table with effective dimensions and penalties:  #>  #>         Term Effective Model Nominal Ratio Penalty #>  (Intercept)         1     1       1     1    0.00 #>          rep         2     2       2     1    0.00 #>          gen        23    23      23     1    0.00 #>     residual        46    72      46     1    7.43 #>  #>  Total Effective Dimension: 72   ## Obtain table of variances. summ2 <- summary(LMM1,                 which = \"variances\") print(summ2) #> Table with variances:  #>  #>   VarComp Variance #>  residual     0.13 #>"},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-109","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.9","title":"LMMsolver 1.0.9","text":"Binomial response can now also modelled fixed = cbind(failure, succes) Categorial response using family = multinomial() Vignette updated, separate section GLMM. doi-link added LMMsolver. argument offset can defined numeric (new) column name data frame. example added predict() function. problem calculation standard errors fixed, minor change spam. bug fixed related convergence GLMM.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-108","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.8","title":"LMMsolver 1.0.8","text":"CRAN release: 2024-08-26 Vignette rewritten, new introduction section. function predict.LMMsolve added. Extension gam models, combining different splxD() possible now. Correction upper bound nominal effective dimension large data sets. new 2D example Sea Surface Temperature added. Issue product two large matrices fixed. Improved efficiency initialization large datasets. Bug grpTheta argument LMMsolve() fixed. Deviance function changes, extra argument relative, giving relative conditional deviance defined McCullagh Nelder. default relative=TRUE, relative=FALSE returns -2*logLik(obj)","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-107","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.7","title":"LMMsolver 1.0.7","text":"CRAN release: 2024-04-16 Improved efficiency models residual argument LMMsolve() used. data.frame trace convergence sequence log-likelihood effective dimensions, added extra output returned LMMsolve(). Bug v1.0.6 GLMM models fixed. Coefficients three way interactions one factor two non-factors now labelled correctly. Standard errors function obtainSmoothTrend() GLMM models now calculated.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-106","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.6","title":"LMMsolver 1.0.6","text":"CRAN release: 2023-11-27 new argument grpTheta LMMsolve() give components model penalty. dependency package sp replaced sf. small bug models 10.000 observations numeric variable random part model fixed. Weights now checked missing values removing observations missing values response. prevents spurious errors response weight missing.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-105","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.5","title":"LMMsolver 1.0.5","text":"CRAN release: 2023-04-14 Small bugs assignment names fixed model coefficients columns dropped model fixed. Calculation standard errors coefficients, coef(obj, se = TRUE). Implementation Generalized Linear Mixed Models (GLMM) additional argument family LMMsolve function. Variance components splines can conditional factor. variance components, implemented cf(var, cond, level) function. 1D 2D splines, additional arguments cond level added. Several small bugs fixed.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-104","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.4","title":"LMMsolver 1.0.4","text":"CRAN release: 2022-12-15 Improved computation time calculation standard errors. Implementation C++ using ‘sparse inverse’. Row-wise Kronecker product spam matrices implemented C++. Important tensor product P-splines improved computation time memory allocation.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-103","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.3","title":"LMMsolver 1.0.3","text":"CRAN release: 2022-08-19 Improved computation time memory allocation, especially important big data many observations (number rows data frame). Replaced default model.matrix function Matrix::sparse.model.matrix generate sparse design matrices. function obtainSmoothTrend standard errors calculated includeIntercept = TRUE. Several small bugs fixed.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-102","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.2","title":"LMMsolver 1.0.2","text":"CRAN release: 2022-04-21 First second order derivatives now calculated correctly. Several small bugs fixed. Updated tests pass checks macM1.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-101","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.1","title":"LMMsolver 1.0.1","text":"CRAN release: 2022-03-28 weights argument LMMsolve function added Function obtainSmoothTrend returns addition predictions standard errors. Generalized Additive Model (GAM) added one-dimensional splines, .e. spl1D() components can added spline argument LMMsolve function Improved efficiency calculating sparse inverse using super-nodes. Replaced original P-splines penalty D'D scaled version far stable many knots. Several bugs fixed.","code":""},{"path":"https://biometris.github.io/LMMsolver/index.html/news/index.html","id":"lmmsolver-100","dir":"Changelog","previous_headings":"","what":"LMMsolver 1.0.0","title":"LMMsolver 1.0.0","text":"CRAN release: 2021-11-02 Initial CRAN version","code":""}]
